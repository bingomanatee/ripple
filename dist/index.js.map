{"version":3,"file":"index.js","sources":["../src/RestPool.js","../src/bottle.js","../src/utils.js","../src/Vector.js","../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/Pool.js","../src/rxCatch.js","../src/Impulse.js","../src/Promiser.js","../src/DataMap.js","../src/RestPoolUtils.js","../src/Signal.js","../src/index.js"],"sourcesContent":["import {Store} from '@wonderlandlabs/looking-glass-engine';\nimport lGet from 'lodash.get';\nimport axios from 'axios';\nimport urlJoin from 'url-join';\n\nexport default (bottle) => {\n\n    bottle.factory('RestPool', ({\n                                    Pool, noop, error, axios, Vector, isUnset,\n                                    REST_ACTIONS, UNSET, restChannels, DataMap\n                                }) => {\n\n        function isIterable(obj) {\n            // checks for null and undefined\n            if (obj == null) {\n                return false;\n            }\n            return typeof obj[Symbol.iterator] === 'function';\n        }\n\n        class RestPool extends Pool {\n        };\n\n        return RestPool;\n    })\n}\n","import Bottle from 'bottlejs';\n\nimport collFactory from './Vector';\nimport poolFactory from './Pool';\nimport impulseFactory from './Impulse';\nimport catchFactory from './rxCatch';\nimport promiserFactory from './Promiser';\nimport unsetFactory from './utils';\nimport restPoolFactory from './RestPool';\nimport restPoolUtilFactory from './RestPoolUtils';\nimport dataMapFactory from './DataMap';\nimport signalFactory from './Signal';\n\nexport default () => {\n    let bottle = new Bottle();\n    unsetFactory(bottle);\n    collFactory(bottle);\n    poolFactory(bottle);\n    catchFactory(bottle);\n    impulseFactory(bottle);\n    promiserFactory(bottle);\n    restPoolFactory(bottle);\n    dataMapFactory(bottle);\n    restPoolUtilFactory(bottle);\n    signalFactory(bottle);\n    return bottle;\n}\n","export default function unsetFactory(bottle) {\n    bottle.factory('UNSET', () => Symbol('UNSET'));\n    bottle.factory('ifUnset', ({UNSET}) => {\n        return (value, defaultValue) => {\n            if ((value === UNSET) || (typeof value === \"undefined\")) {\n                return defaultValue;\n            } else {\n                return value;\n            }\n        }\n    });\n\n    bottle.factory('isUnset', ({UNSET}) => {\n        return (item) => item === UNSET;\n    });\n\n    bottle.factory('Symbol', ({noop}) => {\n        return (string) => ({name: string});\n    });\n\n    bottle.factory('error', () => (msg, info) => {\n        let e = new Error(msg);\n        if (info) {\n            return Object.assign(e, {info})\n        }\n        return e;\n    });\n}\n","import propper from '@wonderlandlabs/propper';\nimport lGet from 'lodash.get';\nimport {filter, map, startWith} from 'rxjs/operators';\nimport uuid from 'uuid/v4';\n\nexport default (bottle) => {\n\n    bottle.factory('Vector', ({UNSET, Update, Impulse, error, noop, isUnset}) => {\n        /**\n         * A channel is a named operation\n         */\n        class Vector {\n            constructor(name, config = {}) {\n                this.pool = lGet(config, 'pool');\n                this.sender = lGet(config, 'sender');\n                this.config = lGet(config, 'config', config);\n                this.schema = lGet(config, 'schema');\n                this._impulseFilter = lGet(config, 'impulseFilter', UNSET);\n                this._paramsToQuery = lGet(config, 'paramsToQuery', noop);\n                this.name = name;\n            }\n\n            impulse(params = {}) {\n                return new Impulse({\n                    vector: this,\n                    params\n                })\n            }\n\n            paramsToQuery(impulse) {\n                return this._paramsToQuery(impulse.params, impulse, this);\n            }\n\n            async send(signal) {\n                try {\n                    signal.response = await this.sender(signal.query, signal);\n                    this.pool.signalStream.next(signal);\n                } catch (error) {\n                    signal.error = error;\n                    this.pool.signalStream.error(signal);\n                }\n                return signal;\n            }\n\n            impulseFilter(impulse) {\n                if (!isUnset(this._impulseFilter)) {\n                    console.log('using _impulseFilter', this.impulseFilter);\n                    return this._impulseFilter(impulse, this);\n                }\n                return (signal => signal.impulse === impulse);\n            }\n\n            get signalStream() {\n                if (!this._signalStream) {\n                    this._signalStream = this.pool.signalStream\n                        .pipe(filter(signal => signal.vector.name === this.name));\n                }\n                return this._signalStream;\n            }\n\n            subscribe(...params) {\n                return this.signalStream.subscribe(...params);\n            }\n        };\n\n        propper(Vector)\n            .addProp('pool', {\n                required: true, type: 'object',\n                onInvalid: (...params) => {\n                    throw error('bad vector.pool', {\n                        field: 'config',\n                        object: 'Pool',\n                        params\n                    })\n                }\n            })\n            .addProp('sender', {\n                required: true, type: 'function',\n                onInvalid: (...params) => {\n                    throw error('bad vector.sender', {\n                        field: 'config',\n                        object: 'Pool',\n                        params\n                    })\n                }\n            })\n            .addProp('schema')\n            .addProp('config', {\n                type: 'object',\n                onInvalid: (...params) => {\n                    throw error('bad vector.config', {\n                        field: 'config',\n                        object: 'Pool',\n                        params\n                    })\n                }\n            })\n            .addProp('name', {\n                required: true, type: 'string',\n                onInvalid: (...params) => {\n                    throw error('bad vector.name', {\n                        field: 'config',\n                        object: 'Pool',\n                        params\n                    })\n                }\n            })\n\n        return Vector;\n    });\n}\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof Symbol !== \"undefined\") {\n\t\tvar iteratorSymbol = Symbol.iterator;\n\t\tif (iteratorSymbol && (iteratorSymbol in target)) {\n\t\t\tvar iterator = target[iteratorSymbol](), step, pact, reject;\n\t\t\tfunction _cycle(result) {\n\t\t\t\ttry {\n\t\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (pact) {\n\t\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpact = result;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t\t\t}\n\t\t\t}\n\t\t\t_cycle();\n\t\t\tif (iterator.return) {\n\t\t\t\tvar _fixup = function(value) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\t\titerator.return();\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\tif (pact && pact.then) {\n\t\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t_fixup();\n\t\t\t}\n\t\t\treturn pact;\n\t\t}\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"value is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof Symbol !== \"undefined\") {\n\t\tvar asyncIteratorSymbol = Symbol.asyncIterator;\n\t\tif (asyncIteratorSymbol && (asyncIteratorSymbol in target)) {\n\t\t\tvar pact = new _Pact();\n\t\t\tvar iterator = target[asyncIteratorSymbol]();\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t\treturn pact;\n\t\t\tfunction _resumeAfterBody(result) {\n\t\t\t\tif (check && !check()) {\n\t\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t\t}\n\t\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t\t}\n\t\t\tfunction _resumeAfterNext(step) {\n\t\t\t\tif (step.done) {\n\t\t\t\t\t_settle(pact, 1);\n\t\t\t\t} else {\n\t\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfunction _reject(error) {\n\t\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t\t}\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, value);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t\tthis[Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))] = function() {\n\t\t\treturn this;\n\t\t};\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\t_entry(_this).then(returnValue, function(error) {\n\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import {Store} from '@wonderlandlabs/looking-glass-engine';\nimport {Subject} from 'rxjs';\nimport {filter, map} from 'rxjs/operators';\nimport lGet from 'lodash.get';\nimport propper from '@wonderlandlabs/propper';\n\nexport default (bottle) => {\n\n    bottle.factory('Pool', function ({Vector, error, noop}) {\n        class Pool {\n            constructor(name, config = {}) {\n                this.name = name;\n                this.vectors = lGet(config, '_vectors', new Map());\n                this.config = lGet(config, 'config', config);\n            }\n\n            addVector(name, config, force = false) {\n                if (this.vectors.has(name) && !force) {\n                    throw error('Attempt to redefine ' + name, {\n                        config,\n                        name,\n                        pool: this\n                    })\n                }\n\n                if (config instanceof Vector) {\n                    config.pool = this;\n                    this.vectors.set(name, config);\n                } else if (typeof config === 'function') {\n                    this.vectors.set(name, new Vector(name, {pool: this, sender: config}));\n                } else {\n                    this.vectors.set(name, new Vector(name, {...config, pool: this, ...config}))\n                }\n                return this;\n            }\n\n            impulse(name, params) {\n                if (!this.vectors.has(name)) {\n                    throw error('attempt to use an unregistered vector', {\n                        pool: this,\n                        name,\n                        params\n                    })\n                }\n\n                return this.vectors.get(name).impulse(params);\n            }\n\n            get signalStream() {\n                if (!this._signalStream) {\n                    this._signalStream = new Subject();\n                }\n                return this._signalStream;\n            }\n\n            subscribe(...params) {\n                return this.signalStream.subscribe(...params);\n            }\n        };\n\n        propper(Pool)\n            .addProp('vectors', ({defaultValue: () => new Map}))\n            .addProp('name', {type: 'string', required: true})\n            .addProp('config', {\n                type: 'object', defaultValue: () => {\n                    return {};\n                },\n                onInvalid: (...params) => {\n                    throw error('bad pool.config', {\n                        field: 'config',\n                        object: 'Pool',\n                        params\n                    })\n                }\n            });\n\n        return Pool;\n    });\n}\n","import {catchError, map, switchMap} from 'rxjs/operators';\nimport {of} from 'rxjs';\n\nexport default function catchFactory(bottle) {\n  bottle.constant('noop', (a) => a);\n\n  const defaultCatcher = (err) => ({error: err, defaultCatcher: true});\n\n  /**\n   * Maps the output to a function that can throw errors.\n   * Re-maps error output to the catcher function.\n   * The resulting subscriber has pseudo-promise syntax\n   * that lets you set the mapper\n   */\n  bottle.factory('rxCatch', ({noop}) => {\n    return (observable, mapper = noop, catcher = defaultCatcher) => {\n      return observable.pipe(\n        switchMap(\n          response => of(response)\n            .pipe(\n              map(mapper),\n              catchError(error => of(catcher(error))))\n        ));\n    }\n  })\n}\n","import lGet from 'lodash.get';\nimport propper from '@wonderlandlabs/propper';\nimport {filter, map, startWith} from 'rxjs/operators';\n\nexport default (bottle) => {\n\n    bottle.factory('IMPULSE_STATE_NEW', ({Symbol}) => Symbol('IMPULSE_STATE_NEW'));\n    bottle.factory('IMPULSE_STATE_QUEUED', ({Symbol}) => Symbol('IMPULSE_STATE_QUEUED'));\n    bottle.factory('IMPULSE_STATE_SENT', ({Symbol}) => Symbol('IMPULSE_STATE_SENT'));\n    bottle.factory('IMPULSE_STATE_RESOLVED', ({Symbol}) => Symbol('IMPULSE_STATE_RESOLVED'));\n    bottle.factory('IMPULSE_STATE_UPDATED', ({Symbol}) => Symbol('IMPULSE_STATE_UPDATED'));\n    bottle.factory('IMPULSE_STATE_ERROR', ({Symbol}) => Symbol('IMPULSE_STATE_ERROR'));\n    bottle.factory('IMPULSE_STATE_COMPLETE', ({Symbol}) => Symbol('IMPULSE_STATE_COMPLETE'));\n\n    bottle.factory('Impulse', ({\n                                   UNSET, error, Signal\n                               }) => {\n\n            /**\n             * An impulse is a single call to a channel.\n             * It exists for an indefinate period before it is performed,\n             * so it can be used as a \"draft\" or prepared query that you\n             * build up and send.\n             *\n             * Once set, its response subscribes to the pools updates\n             * stream so that it can change (or present warnings) when\n             * the pool's other impulse updates are relevant to the response.\n             */\n            class Impulse {\n                constructor(config = {}) {\n                    this.vector = lGet(config, 'vector');\n                    this._params = lGet(config, 'params', config);\n                }\n\n                get params() {\n                    // @TODO: Immutable?\n                    return this._params;\n                }\n\n                get pool() {\n                    return this.vector.pool;\n                }\n\n                async send() {\n                    const signal = new Signal(this);\n                    return this.vector.send(signal);\n                }\n\n                get signalStream() {\n                    if (!this._signalStream) {\n                        this._signalStream = this.vector.signalStream\n                            .pipe(filter(this.vector.impulseFilter(this)));\n                    }\n                    return this._signalStream;\n                }\n\n                subscribe(...params) {\n                    return this.signalStream.subscribe(...params);\n                }\n\n            }\n\n            propper(Impulse)\n                .addProp('vector', {\n                    required: true,\n                    type: 'object',\n                    onInvalid:\n                        (err) => {\n                            throw error('bad impulse.config', {\n                                field: 'vector',\n                                object: 'Impulse',\n                                err\n                            })\n                        }\n                });\n\n            return Impulse;\n        }\n    )\n    ;\n}\n","export default (bottle) => {\n\n    bottle.factory('Promiser', ({UNSET}) => {\n        return class Promiser {\n            constructor() {\n                this._resolved = false;\n                this.promise = new Promise((done, fail) => {\n                    this._done = done;\n                    this._fail = fail;\n                });\n            }\n\n            get resolved() {\n                return this._resolved;\n            }\n\n            /**\n             * _resolve (optionally) sets the final value of the change\n             * and closes the promise. It can only execute once.\n             *\n             * If value is (or is set to) a value then the change\n             * resolves that value and takes the result as the change's value\n             * then returns it.\n             *\n             * @returns {Promise}\n             * @param response\n             */\n            resolve(response) {\n                if (this.resolved) {\n                    return this.promise;\n                }\n\n                this.response = response;\n\n                this._resolved = true;\n                this._done(response);\n                return this.promise;\n            }\n\n            reject(error) {\n                if (this.resolved) {\n                    return this.promise;\n                }\n\n                this._resolved = true;\n\n                this.error = error;\n\n                this._fail(this);\n                return this.promise;\n            }\n\n            then(...args) {\n                return this.promise.then(...args);\n            }\n\n            catch(listener) {\n                return this.promise.catch(listener);\n            }\n        }\n\n\n    })\n\n\n}\n","export default bottle => {\n    bottle.factory('DataMap', () => {\n        return class DataMap {\n            constructor(records, pool) {\n                this._map = new Map();\n                this.pool = pool;\n                (Array.isArray(records) ? records : [records]).forEach(data => {\n                    const id = data[pool.idField];\n                    this.set(id, data);\n                })\n            }\n\n            get size() {\n                return this._map.size;\n            }\n\n            entries() {\n                return this._map.entries();\n            }\n\n            get(k){\n                return this._map.get(k);\n            }\n\n            set(...a) {\n                return this._map.set(...a);\n            }\n\n            has(k) {\n                return this._map.has(k);\n            }\n\n            keys() {\n                return this._map.keys()\n            }\n\n            clear() {\n                return this._map.clear()\n            }\n\n            delete(k) {\n                return this._map.delete(k)\n            }\n\n            values() {\n                return this._map.values()\n            }\n\n            forEach(fn) {\n                return this._map.forEach(fn)\n            }\n\n            overlaps(otherDataMap) {\n                if (!otherDataMap instanceof DataMap) {\n                    return false;\n                }\n                if (otherDataMap.size < this.size) {\n                    return otherDataMap.overlaps(this);\n                }\n                let keys = this.keys();\n                let next = keys.next();\n                while (!next.done) {\n                    if (otherDataMap.has(next.value)) {\n                        return true;\n                    }\n                    next = keys.next();\n                }\n\n                return false;\n            }\n\n            sharedKeys(otherDataMap) {\n                if (!otherDataMap instanceof DataMap) {\n                    return false;\n                }\n                if (otherDataMap.size < this.size) {\n                    return otherDataMap.sharedKeys(this);\n                }\n                let keys = this.keys();\n                let shared = [];\n                let next = keys.next();\n\n                while (!next.done) {\n                    if (otherDataMap.has(next.value)) {\n                        shared.push(next.value);\n                    }\n                    next = keys.next();\n                }\n\n                return shared;\n            }\n\n            clone(){\n                let dm = new DataMap([], this.pool);\n                dm.updateFrom(this, true);\n                return dm;\n            }\n\n            /**\n             * copy shared values from the other map into this one.\n             * @param otherMap\n             * @param useAll {bool}\n             * @param merge {bool} if true (default), new data is combined with old data. So fields can be added but not deleted.\n             */\n            updateFrom(otherMap, useAll = false, merge = true) {\n                if (otherMap.pool !== this.pool) {\n                    console.log(error('attempt to merge data from wrong pool', {\n                        map: this,\n                        otherMap\n                    }))\n                }\n\n                otherMap.forEach((value, key) => {\n                    if ((this.has(key))) {\n                        let merged = merge ? Object.assign({}, this.get(key), value): value;\n                        this.set(key, merged);\n                    } else if (useAll) {\n                        this.set(key, value);\n                    }\n                });\n                return this;\n            }\n        }\n    });\n}\n","import lGet from 'lodash.get';\nimport axios from 'axios';\nimport {filter, map} from 'rxjs/operators';\n\nexport default (bottle) => {\n    bottle.constant('REST_ACTIONS', 'get,put,post,delete,getAll'.split(','));\n\n    bottle.factory('axios', () => axios);\n\n    bottle.factory('observeSingle', ({restDataFromImpulse, isUnset, UNSET, DataMap, noop}) => {\n        return noop;\n    });\n\n    bottle.factory('restChannels', ({UNSET, observeSingle, noop, error, restDataFromImpulse, DataMap, isUnset}) => {\n        return noop;\n    });\n\n    bottle.factory('restDataFromImpulse', ({UNSET, noop}) => {\n        return noop;\n    });\n}\n","import {Store} from '@wonderlandlabs/looking-glass-engine';\nimport {filter, map} from 'rxjs/operators';\nimport lget from 'lodash.get';\nimport uuid from 'uuid/v4';\n\nexport default (bottle) => {\n\n    bottle.factory('Signal', ({UNSET, Update, error, noop, isUnset}) => {\n        /**\n         * A channel is a named operation\n         */\n        return class Signal {\n            constructor(impulse) {\n                this._impulse = impulse;\n            }\n\n            toJSON(){\n                return {\n                    pool: this.pool.name,\n                    vector: this.vector.name,\n                    query: JSON.stringify(this.query)\n                }\n            }\n\n            get pool() {\n                return this.impulse.pool;\n            }\n\n            get impulse() {\n                return this._impulse;\n            }\n\n            get vector() {\n                return this.impulse.vector;\n            }\n\n            get params() {\n                return this.impulse.params;\n            }\n\n            get query() {\n                if (!this._query) {\n                    this._query = this.vector.paramsToQuery(this.impulse);\n                }\n                return this._query;\n            }\n        };\n    });\n}\n","import bottle from './bottle';\n\nconst myBottle = bottle();\nconst {\n    Pool,\n    RestPool,\n    Vector,\n    Impulse,\n    DataMap,\n    axios\n} = myBottle.container;\n\nexport {\n    Pool,\n    RestPool,\n    Vector,\n    Impulse,\n    bottle,\n    DataMap,\n    axios\n}\n\nexport default {\n    Pool,\n    RestPool,\n    Vector,\n    Impulse,\n    DataMap,\n    bottle,\n    axios\n}\n"],"names":["bottle","Bottle","factory","Symbol","ref","value","defaultValue","UNSET","item","string","name","msg","info","e","Error","Object","assign","unsetFactory","Vector","constructor","config","pool","lGet","sender","schema","_impulseFilter","_paramsToQuery","noop","impulse","params","Impulse","this","paramsToQuery","send","signal","body","recover","result","_this","query","response","signalStream","next","then","error","impulseFilter","isUnset","log","_signalStream","pipe","filter","vector","subscribe","propper","addProp","required","type","onInvalid","field","object","collFactory","Pool","vectors","Map","addVector","force","has","set","get","Subject","poolFactory","constant","a","defaultCatcher","err","observable","mapper","catcher","switchMap","of","map","catchError","catchFactory","_params","Signal","impulseFactory","_resolved","promise","Promise","done","fail","_done","_fail","resolved","resolve","reject","args","catch","listener","promiserFactory","restPoolFactory","records","_map","Array","isArray","forEach","data","idField","size","entries","k","keys","clear","delete","values","fn","overlaps","otherDataMap","DataMap","sharedKeys","shared","push","clone","dm","updateFrom","otherMap","useAll","merge","console","key","merged","dataMapFactory","split","axios","restPoolUtilFactory","_impulse","toJSON","JSON","stringify","_query","signalFactory","container","RestPool"],"mappings":"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"}