{"version":3,"file":"index.js","sources":["../node_modules/strict-uri-encode/index.js","../node_modules/object-assign/index.js","../node_modules/query-string/index.js","../node_modules/decode-uri-component/index.js","../src/bottle.js","../src/utils.js","../src/Vector.js","../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/Pool.js","../src/rxCatch.js","../src/Impulse.js","../src/Promiser.js","../src/RestPool.js","../src/DataMap.js","../src/RestPoolUtils.js","../src/Signal.js","../src/index.js"],"sourcesContent":["'use strict';\nmodule.exports = function (str) {\n\treturn encodeURIComponent(str).replace(/[!'()*]/g, function (c) {\n\t\treturn '%' + c.charCodeAt(0).toString(16).toUpperCase();\n\t});\n};\n","/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n","'use strict';\nvar strictUriEncode = require('strict-uri-encode');\nvar objectAssign = require('object-assign');\nvar decodeComponent = require('decode-uri-component');\n\nfunction encoderForArrayFormat(opts) {\n\tswitch (opts.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn function (key, value, index) {\n\t\t\t\treturn value === null ? [\n\t\t\t\t\tencode(key, opts),\n\t\t\t\t\t'[',\n\t\t\t\t\tindex,\n\t\t\t\t\t']'\n\t\t\t\t].join('') : [\n\t\t\t\t\tencode(key, opts),\n\t\t\t\t\t'[',\n\t\t\t\t\tencode(index, opts),\n\t\t\t\t\t']=',\n\t\t\t\t\tencode(value, opts)\n\t\t\t\t].join('');\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn function (key, value) {\n\t\t\t\treturn value === null ? encode(key, opts) : [\n\t\t\t\t\tencode(key, opts),\n\t\t\t\t\t'[]=',\n\t\t\t\t\tencode(value, opts)\n\t\t\t\t].join('');\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn function (key, value) {\n\t\t\t\treturn value === null ? encode(key, opts) : [\n\t\t\t\t\tencode(key, opts),\n\t\t\t\t\t'=',\n\t\t\t\t\tencode(value, opts)\n\t\t\t\t].join('');\n\t\t\t};\n\t}\n}\n\nfunction parserForArrayFormat(opts) {\n\tvar result;\n\n\tswitch (opts.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn function (key, value, accumulator) {\n\t\t\t\tresult = /\\[(\\d*)\\]$/.exec(key);\n\n\t\t\t\tkey = key.replace(/\\[\\d*\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = {};\n\t\t\t\t}\n\n\t\t\t\taccumulator[key][result[1]] = value;\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn function (key, value, accumulator) {\n\t\t\t\tresult = /(\\[\\])$/.exec(key);\n\t\t\t\tkey = key.replace(/\\[\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t} else if (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = [value];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn function (key, value, accumulator) {\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\t}\n}\n\nfunction encode(value, opts) {\n\tif (opts.encode) {\n\t\treturn opts.strict ? strictUriEncode(value) : encodeURIComponent(value);\n\t}\n\n\treturn value;\n}\n\nfunction keysSorter(input) {\n\tif (Array.isArray(input)) {\n\t\treturn input.sort();\n\t} else if (typeof input === 'object') {\n\t\treturn keysSorter(Object.keys(input)).sort(function (a, b) {\n\t\t\treturn Number(a) - Number(b);\n\t\t}).map(function (key) {\n\t\t\treturn input[key];\n\t\t});\n\t}\n\n\treturn input;\n}\n\nfunction extract(str) {\n\tvar queryStart = str.indexOf('?');\n\tif (queryStart === -1) {\n\t\treturn '';\n\t}\n\treturn str.slice(queryStart + 1);\n}\n\nfunction parse(str, opts) {\n\topts = objectAssign({arrayFormat: 'none'}, opts);\n\n\tvar formatter = parserForArrayFormat(opts);\n\n\t// Create an object with no prototype\n\t// https://github.com/sindresorhus/query-string/issues/47\n\tvar ret = Object.create(null);\n\n\tif (typeof str !== 'string') {\n\t\treturn ret;\n\t}\n\n\tstr = str.trim().replace(/^[?#&]/, '');\n\n\tif (!str) {\n\t\treturn ret;\n\t}\n\n\tstr.split('&').forEach(function (param) {\n\t\tvar parts = param.replace(/\\+/g, ' ').split('=');\n\t\t// Firefox (pre 40) decodes `%3D` to `=`\n\t\t// https://github.com/sindresorhus/query-string/pull/37\n\t\tvar key = parts.shift();\n\t\tvar val = parts.length > 0 ? parts.join('=') : undefined;\n\n\t\t// missing `=` should be `null`:\n\t\t// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n\t\tval = val === undefined ? null : decodeComponent(val);\n\n\t\tformatter(decodeComponent(key), val, ret);\n\t});\n\n\treturn Object.keys(ret).sort().reduce(function (result, key) {\n\t\tvar val = ret[key];\n\t\tif (Boolean(val) && typeof val === 'object' && !Array.isArray(val)) {\n\t\t\t// Sort object keys, not values\n\t\t\tresult[key] = keysSorter(val);\n\t\t} else {\n\t\t\tresult[key] = val;\n\t\t}\n\n\t\treturn result;\n\t}, Object.create(null));\n}\n\nexports.extract = extract;\nexports.parse = parse;\n\nexports.stringify = function (obj, opts) {\n\tvar defaults = {\n\t\tencode: true,\n\t\tstrict: true,\n\t\tarrayFormat: 'none'\n\t};\n\n\topts = objectAssign(defaults, opts);\n\n\tif (opts.sort === false) {\n\t\topts.sort = function () {};\n\t}\n\n\tvar formatter = encoderForArrayFormat(opts);\n\n\treturn obj ? Object.keys(obj).sort(opts.sort).map(function (key) {\n\t\tvar val = obj[key];\n\n\t\tif (val === undefined) {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (val === null) {\n\t\t\treturn encode(key, opts);\n\t\t}\n\n\t\tif (Array.isArray(val)) {\n\t\t\tvar result = [];\n\n\t\t\tval.slice().forEach(function (val2) {\n\t\t\t\tif (val2 === undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tresult.push(formatter(key, val2, result.length));\n\t\t\t});\n\n\t\t\treturn result.join('&');\n\t\t}\n\n\t\treturn encode(key, opts) + '=' + encode(val, opts);\n\t}).filter(function (x) {\n\t\treturn x.length > 0;\n\t}).join('&') : '';\n};\n\nexports.parseUrl = function (str, opts) {\n\treturn {\n\t\turl: str.split('?')[0] || '',\n\t\tquery: parse(extract(str), opts)\n\t};\n};\n","'use strict';\nvar token = '%[a-f0-9]{2}';\nvar singleMatcher = new RegExp(token, 'gi');\nvar multiMatcher = new RegExp('(' + token + ')+', 'gi');\n\nfunction decodeComponents(components, split) {\n\ttry {\n\t\t// Try to decode the entire string first\n\t\treturn decodeURIComponent(components.join(''));\n\t} catch (err) {\n\t\t// Do nothing\n\t}\n\n\tif (components.length === 1) {\n\t\treturn components;\n\t}\n\n\tsplit = split || 1;\n\n\t// Split the array in 2 parts\n\tvar left = components.slice(0, split);\n\tvar right = components.slice(split);\n\n\treturn Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n}\n\nfunction decode(input) {\n\ttry {\n\t\treturn decodeURIComponent(input);\n\t} catch (err) {\n\t\tvar tokens = input.match(singleMatcher);\n\n\t\tfor (var i = 1; i < tokens.length; i++) {\n\t\t\tinput = decodeComponents(tokens, i).join('');\n\n\t\t\ttokens = input.match(singleMatcher);\n\t\t}\n\n\t\treturn input;\n\t}\n}\n\nfunction customDecodeURIComponent(input) {\n\t// Keep track of all the replacements and prefill the map with the `BOM`\n\tvar replaceMap = {\n\t\t'%FE%FF': '\\uFFFD\\uFFFD',\n\t\t'%FF%FE': '\\uFFFD\\uFFFD'\n\t};\n\n\tvar match = multiMatcher.exec(input);\n\twhile (match) {\n\t\ttry {\n\t\t\t// Decode as big chunks as possible\n\t\t\treplaceMap[match[0]] = decodeURIComponent(match[0]);\n\t\t} catch (err) {\n\t\t\tvar result = decode(match[0]);\n\n\t\t\tif (result !== match[0]) {\n\t\t\t\treplaceMap[match[0]] = result;\n\t\t\t}\n\t\t}\n\n\t\tmatch = multiMatcher.exec(input);\n\t}\n\n\t// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n\treplaceMap['%C2'] = '\\uFFFD';\n\n\tvar entries = Object.keys(replaceMap);\n\n\tfor (var i = 0; i < entries.length; i++) {\n\t\t// Replace all decoded components\n\t\tvar key = entries[i];\n\t\tinput = input.replace(new RegExp(key, 'g'), replaceMap[key]);\n\t}\n\n\treturn input;\n}\n\nmodule.exports = function (encodedURI) {\n\tif (typeof encodedURI !== 'string') {\n\t\tthrow new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\n\t}\n\n\ttry {\n\t\tencodedURI = encodedURI.replace(/\\+/g, ' ');\n\n\t\t// Try the built in decoder first\n\t\treturn decodeURIComponent(encodedURI);\n\t} catch (err) {\n\t\t// Fallback to a more advanced decoder\n\t\treturn customDecodeURIComponent(encodedURI);\n\t}\n};\n","import Bottle from 'bottlejs';\n\nimport collFactory from './Vector';\nimport poolFactory from './Pool';\nimport impulseFactory from './Impulse';\nimport catchFactory from './rxCatch';\nimport promiserFactory from './Promiser';\nimport unsetFactory from './utils';\nimport restPoolFactory from './RestPool';\nimport restPoolUtilFactory from './RestPoolUtils';\nimport dataMapFactory from './DataMap';\nimport signalFactory from './Signal';\n\nexport default () => {\n    let bottle = new Bottle();\n    unsetFactory(bottle);\n    collFactory(bottle);\n    poolFactory(bottle);\n    catchFactory(bottle);\n    impulseFactory(bottle);\n    promiserFactory(bottle);\n    restPoolFactory(bottle);\n    dataMapFactory(bottle);\n    restPoolUtilFactory(bottle);\n    signalFactory(bottle);\n    return bottle;\n}\n","export default function unsetFactory(bottle) {\n    bottle.factory('UNSET', ({Symbol}) => Symbol('UNSET'));\n    bottle.factory('ifUnset', ({UNSET}) => {\n        return (value, defaultValue) => {\n            if ((value === UNSET) || (typeof value === \"undefined\")) {\n                return defaultValue;\n            } else {\n                return value;\n            }\n        }\n    });\n\n    bottle.factory('isUnset', ({UNSET}) => {\n        return (item) => item === UNSET;\n    });\n\n    bottle.factory('Symbol', ({noop}) => {\n        return (string) => ({name: string});\n    });\n\n    bottle.factory('error', () => (msg, info) => {\n        let e = new Error(msg);\n        if (info) {\n            return Object.assign(e, {info})\n        }\n        return e;\n    });\n}\n","import propper from '@wonderlandlabs/propper';\nimport lGet from 'lodash.get';\nimport {filter, map, startWith} from 'rxjs/operators';\nimport uuid from 'uuid/v4';\n\nexport default (bottle) => {\n\n    bottle.factory('Vector', ({UNSET, Update, Impulse, error, noop, isUnset}) => {\n        /**\n         * A channel is a named operation\n         */\n        class Vector {\n            constructor(name, config = {}) {\n                this.pool = lGet(config, 'pool');\n                this.sender = lGet(config, 'sender');\n                this.config = lGet(config, 'config', config);\n                this.schema = lGet(config, 'schema');\n                this._makeImpulseStream = lGet(config, 'makeImpulseStream', UNSET);\n                this._paramsToQuery = lGet(config, 'paramsToQuery', noop);\n                this.idempotent = lGet(config, 'idempotent', false)\n                this.name = name;\n            }\n\n            TYPE='VECTOR'\n\n            impulse(params = {}) {\n                return new Impulse({\n                    vector: this,\n                    params\n                })\n            }\n\n            paramsToQuery(impulse) {\n                return this._paramsToQuery(impulse.params, impulse, this);\n            }\n\n            async send(signal) {\n                try {\n                    signal.response = await this.sender(signal.query, signal);\n                    if (!(isUnset(signal.impulse.response))) {\n                        signal.impulse.response = signal.response;\n                    }\n                    return Promise.resolve(signal);\n                } catch (error) {\n                    signal.error = error;\n                    return Promise.reject(signal);\n                }\n            }\n\n            makeImpulseStream(impulse){\n                if(!isUnset(this._makeImpulseStream)){\n                    return this._makeImpulseStream(impulse, this);\n                }\n                const pool = impulse.pool;\n                return pool.signalStream.pipe(filter(signal => signal.impulse.id === impulse.id))\n            }\n\n            get signalStream() {\n                if (!this._signalStream) {\n                    this._signalStream = this.pool.signalStream\n                        .pipe(filter(signal => signal.vector.name === this.name));\n                }\n                return this._signalStream;\n            }\n\n            subscribe(...params) {\n                return this.signalStream.subscribe(...params);\n            }\n        };\n\n        propper(Vector)\n            .addProp('idempotent', {\n                type: 'boolean',\n                defaultValue: false\n            })\n            .addProp('pool', {\n                required: true, type: 'object',\n                onInvalid: (...params) => {\n                    throw error('bad vector.pool', {\n                        field: 'config',\n                        object: 'Pool',\n                        params\n                    })\n                }\n            })\n            .addProp('sender', {\n                required: true, type: 'function',\n                onInvalid: (...params) => {\n                    throw error('bad vector.sender', {\n                        field: 'config',\n                        object: 'Pool',\n                        params\n                    })\n                }\n            })\n            .addProp('schema')\n            .addProp('config', {\n                type: 'object',\n                onInvalid: (...params) => {\n                    throw error('bad vector.config', {\n                        field: 'config',\n                        object: 'Pool',\n                        params\n                    })\n                }\n            })\n            .addProp('name', {\n                required: true, type: 'string',\n                onInvalid: (...params) => {\n                    throw error('bad vector.name', {\n                        field: 'config',\n                        object: 'Pool',\n                        params\n                    })\n                }\n            })\n\n        return Vector;\n    });\n}\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof Symbol !== \"undefined\") {\n\t\tvar iteratorSymbol = Symbol.iterator;\n\t\tif (iteratorSymbol && (iteratorSymbol in target)) {\n\t\t\tvar iterator = target[iteratorSymbol](), step, pact, reject;\n\t\t\tfunction _cycle(result) {\n\t\t\t\ttry {\n\t\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (pact) {\n\t\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpact = result;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t\t\t}\n\t\t\t}\n\t\t\t_cycle();\n\t\t\tif (iterator.return) {\n\t\t\t\tvar _fixup = function(value) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\t\titerator.return();\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\tif (pact && pact.then) {\n\t\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t_fixup();\n\t\t\t}\n\t\t\treturn pact;\n\t\t}\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"value is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof Symbol !== \"undefined\") {\n\t\tvar asyncIteratorSymbol = Symbol.asyncIterator;\n\t\tif (asyncIteratorSymbol && (asyncIteratorSymbol in target)) {\n\t\t\tvar pact = new _Pact();\n\t\t\tvar iterator = target[asyncIteratorSymbol]();\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t\treturn pact;\n\t\t\tfunction _resumeAfterBody(result) {\n\t\t\t\tif (check && !check()) {\n\t\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t\t}\n\t\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t\t}\n\t\t\tfunction _resumeAfterNext(step) {\n\t\t\t\tif (step.done) {\n\t\t\t\t\t_settle(pact, 1);\n\t\t\t\t} else {\n\t\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfunction _reject(error) {\n\t\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t\t}\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, value);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t\tthis[Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))] = function() {\n\t\t\treturn this;\n\t\t};\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\t_entry(_this).then(returnValue, function(error) {\n\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import {Store} from '@wonderlandlabs/looking-glass-engine';\nimport {Subject} from 'rxjs';\nimport {filter, map} from 'rxjs/operators';\nimport lGet from 'lodash.get';\nimport propper from '@wonderlandlabs/propper';\n\nexport default (bottle) => {\n\n    bottle.factory('Pool', function ({Vector, error}) {\n        class Pool {\n            constructor(name, config = {}) {\n                this.name = name;\n                this.vectors = lGet(config, '_vectors', new Map());\n                this.config = lGet(config, 'config', config);\n            }\n\n            addVector(name, config, force = false) {\n                if (this.vectors.has(name) && !force) {\n                    throw error('Attempt to redefine ' + name, {\n                        config,\n                        name,\n                        pool: this\n                    })\n                }\n\n                if (config instanceof Vector) {\n                    config.pool = this;\n                    this.vectors.set(name, config);\n                } else if (typeof config === 'function') {\n                    this.vectors.set(name, new Vector(name, {pool: this, sender: config}));\n                } else {\n                    this.vectors.set(name, new Vector(name, {...config, pool: this, ...config}))\n                }\n                return this;\n            }\n\n            impulse(name, ...params) {\n                if (!this.vectors.has(name)) {\n                    throw error('attempt to use an unregistered vector', {\n                        pool: this,\n                        name,\n                        params\n                    })\n                }\n\n                return this.vectors.get(name).impulse(params);\n            }\n\n            get signalStream() {\n                if (!this._signalStream) {\n                    this._signalStream = new Subject();\n                }\n                return this._signalStream;\n            }\n\n            subscribe(...params) {\n                return this.signalStream.subscribe(...params);\n            }\n\n            toJSON(){\n                return {\n                    name: this.name,\n                    TYPE: 'POOL',\n                    vectors: Array.from(this.vectors.keys())\n                }\n            }\n        }\n\n        propper(Pool)\n            .addProp('vectors', ({defaultValue: () => new Map}))\n            .addProp('name', {type: 'string', required: true})\n            .addProp('config', {\n                type: 'object', defaultValue: () => {\n                    return {};\n                },\n                onInvalid: (...params) => {\n                    throw error('bad pool.config', {\n                        field: 'config',\n                        object: 'Pool',\n                        params\n                    })\n                }\n            });\n\n        return Pool;\n    });\n}\n","import {catchError, map, switchMap} from 'rxjs/operators';\nimport {of} from 'rxjs';\n\nexport default function catchFactory(bottle) {\n  bottle.constant('noop', (a) => a);\n\n  const defaultCatcher = (err) => ({error: err, defaultCatcher: true});\n\n  /**\n   * Maps the output to a function that can throw errors.\n   * Re-maps error output to the catcher function.\n   * The resulting subscriber has pseudo-promise syntax\n   * that lets you set the mapper\n   */\n  bottle.factory('rxCatch', ({noop}) => {\n    return (observable, mapper = noop, catcher = defaultCatcher) => {\n      return observable.pipe(\n        switchMap(\n          response => of(response)\n            .pipe(\n              map(mapper),\n              catchError(error => of(catcher(error))))\n        ));\n    }\n  })\n}\n","import lGet from 'lodash.get';\nimport uuid from 'uuid/v4';\nimport propper from '@wonderlandlabs/propper';\nimport {filter, map, startWith} from 'rxjs/operators';\n\nexport default (bottle) => {\n\n    bottle.factory('IMPULSE_STATE_NEW', ({Symbol}) => Symbol('IMPULSE_STATE_NEW'));\n    bottle.factory('IMPULSE_STATE_QUEUED', ({Symbol}) => Symbol('IMPULSE_STATE_QUEUED'));\n    bottle.factory('IMPULSE_STATE_SENT', ({Symbol}) => Symbol('IMPULSE_STATE_SENT'));\n    bottle.factory('IMPULSE_STATE_RESOLVED', ({Symbol}) => Symbol('IMPULSE_STATE_RESOLVED'));\n    bottle.factory('IMPULSE_STATE_UPDATED', ({Symbol}) => Symbol('IMPULSE_STATE_UPDATED'));\n    bottle.factory('IMPULSE_STATE_ERROR', ({Symbol}) => Symbol('IMPULSE_STATE_ERROR'));\n    bottle.factory('IMPULSE_STATE_COMPLETE', ({Symbol}) => Symbol('IMPULSE_STATE_COMPLETE'));\n\n    bottle.factory('Impulse', ({\n                                   UNSET, error, Signal, isUnset\n                               }) => {\n\n            /**\n             * An impulse is a single call to a channel.\n             * It exists for an indefinate period before it is performed,\n             * so it can be used as a \"draft\" or prepared query that you\n             * build up and send.\n             *\n             * Once set, its response subscribes to the pools updates\n             * stream so that it can change (or present warnings) when\n             * the pool's other impulse updates are relevant to the response.\n             */\n            class Impulse {\n                constructor(config = {}) {\n                    this.id = uuid();\n                    this.vector = lGet(config, 'vector');\n                    this.params = lGet(config, 'params', config);\n                }\n\n                get pool() {\n                    return this.vector.pool;\n                }\n\n                toJSON() {\n                    return {\n                        id: this.id,\n                        TYPE: 'Impulse',\n                        vector: this.vector.name,\n                        params: this.params,\n                        sent: this.sent,\n                        response: this.response\n                    };\n                }\n\n                send() {\n                    if (this._pending) {\n                        if (this.vector.idempotent) {\n                            return this._pending;\n                        } else {\n                            return this._pending\n                                .then(() => this.send())\n                                .catch(() => this.send());\n                        }\n                    } else {\n                        const signal = new Signal(this);\n                        this._pending = this.vector.send(signal)\n                            .then((signal) => {\n                                this._pending = false;\n                                if (isUnset(this.response)) {\n                                    this.response = signal.response;\n                                }\n                                this.pool.signalStream.next(signal);\n                                return signal;\n                            })\n                            .catch(() => {\n                                this._pending = false;\n                                this.pool.signalStream.error(signal);\n                                return signal;\n                            });\n                        this.sent = true;\n                    }\n\n                    return this._pending;\n                }\n\n                get signalStream() {\n                    if (!this._signalStream) {\n                        this._signalStream = this.vector.makeImpulseStream(this);\n                    }\n                    return this._signalStream;\n                }\n\n                subscribe(...params) {\n                    if (this._completed) {\n                        throw error('cannot subscribe to completed impulse', {\n                            impulse: this, params\n                        });\n                    }\n                    const sub = this.signalStream.subscribe(...params);\n                    this._subs.push(sub);\n                    return sub;\n                }\n\n                get _subs() {\n                    if (!this.__subs) {\n                        this.__subs = [];\n                    }\n                    return this.__subs;\n                }\n\n                complete() {\n                    this._completed = true;\n                    if (this._signalStream) {\n                        this._signalStream.complete();\n                    }\n\n                    if (this.__subs) {\n                        this.__subs.forEach(s => s.unsubscribe());\n                    }\n\n                    delete this.__subs;\n                }\n\n                /**\n                 * Get the identity property of the impulse's parameters.\n                 */\n                paramsToID() {\n                    if (/(get|post|delete)/.test(this.vector.name)) {\n                        const firstQuery = this.pool.impulseParamsToQuery(this);\n                        if (!(isUnset(firstQuery.id || firstQuery.id === ''))) {\n                            this.identity = firstQuery.id;\n                        }\n                    }\n                }\n\n                signalToID(signal) {\n                    if (signal.impulse.id !== this.id) {\n                        return;\n                    }\n                    if (signal.response && (typeof signal.response === 'object')) {\n                        this.identity = signal.response[this.pool.identityField];\n                    }\n                }\n            }\n\n\n            propper(Impulse)\n                .addProp('params', {\n                    type: 'array',\n                    required: true\n                })\n                .addProp('response', {\n                    defaultValue: () => UNSET\n                })\n                .addProp('sent', {\n                    type: 'boolean',\n                    defaultValue: false\n                })\n                .addProp('vector', {\n                    required: true,\n                    type: 'object',\n                    onInvalid:\n                        (err) => {\n                            throw error('bad impulse.config', {\n                                field: 'vector',\n                                object: 'Impulse',\n                                err\n                            });\n                        }\n                });\n\n            return Impulse;\n        }\n    );\n};\n","export default (bottle) => {\n\n    bottle.factory('Promiser', ({UNSET}) => {\n        return class Promiser {\n            constructor() {\n                this._resolved = false;\n                this.promise = new Promise((done, fail) => {\n                    this._done = done;\n                    this._fail = fail;\n                });\n            }\n\n            get resolved() {\n                return this._resolved;\n            }\n\n            /**\n             * _resolve (optionally) sets the final value of the change\n             * and closes the promise. It can only execute once.\n             *\n             * If value is (or is set to) a value then the change\n             * resolves that value and takes the result as the change's value\n             * then returns it.\n             *\n             * @returns {Promise}\n             * @param response\n             */\n            resolve(response) {\n                if (this.resolved) {\n                    return this.promise;\n                }\n\n                this.response = response;\n\n                this._resolved = true;\n                this._done(response);\n                return this.promise;\n            }\n\n            reject(error) {\n                if (this.resolved) {\n                    return this.promise;\n                }\n\n                this._resolved = true;\n\n                this.error = error;\n\n                this._fail(this);\n                return this.promise;\n            }\n\n            then(...args) {\n                return this.promise.then(...args);\n            }\n\n            catch(listener) {\n                return this.promise.catch(listener);\n            }\n        }\n\n\n    })\n\n\n}\n","import {Store} from '@wonderlandlabs/looking-glass-engine';\nimport lGet from 'lodash.get';\nimport axios from 'axios';\nimport urlJoin from 'url-join';\nimport querystring from 'query-string';\nimport propper from \"@wonderlandlabs/propper\";\n\nexport default (bottle) => {\n\n    bottle.factory('RestPool', ({\n                                    Pool, error, isUnset, noop, axios, UNSET,\n                                    REST_ACTIONS, restVectors, impulseParamsToQuery\n                                }) => {\n\n        class RestPool extends Pool {\n            constructor(name, config) {\n                super(name, config);\n                this.baseURL = lGet(config, 'baseURL', '/');\n                this.prepQuery = lGet(config, 'prepQuery', null);\n                this.identityField = lGet(config, 'identityField', 'id');\n                this.responseToData = lGet(config, 'responseToData', noop);\n                this.dataToClass = lGet(config, 'dataToClass', noop);\n                this.connection = lGet(config, 'connection', axios);\n                this.impulseParamsToQuery = lGet(config, 'impulseParamsToQuery', impulseParamsToQuery);\n\n                let restActions = lGet(config, 'restActions', UNSET);\n                if (isUnset(restActions)) {\n                    REST_ACTIONS.forEach((action) => {\n                        this.addVector(action, restVectors[action]);\n                    });\n                } else {\n                    restActions.forEach((action) => {\n                        if (typeof action === 'string') {\n                            this.addVector(action, restVectors[action]);\n                        } else if (Array.isArray(action)) {\n                            const [name, config] = action;\n                            this.addVector(name, config);\n                        } else {\n                            throw error('strange action for pool ' + name, {action});\n                        }\n                    });\n                }\n            }\n\n            toJSON(){\n                return {\n                    name: this.name,\n                    TYPE: 'RestPool',\n                    baseURL: this.baseURL,\n                    vectors: Array.from(this.vectors.keys())\n                };\n            }\n\n            url(id, queryParams) {\n                let url = (id === '' || isUnset(id)) ? this.baseURL : urlJoin(this.baseURL, id);\n                const q =  querystring.stringify(queryParams);\n                if (q) {\n                    url += '?' + q;\n                }\n                // console.log('url from ', this.baseURL, 'id =', id, 'queryParams = ', queryParams, '=', url);\n                return url;\n            }\n        };\n\n        propper(RestPool)\n            .addProp('identityField', {\n                type: 'string',\n                required: true,\n                defaultValue: 'id'\n            })\n            .addProp('connection', {\n                required: true,\n                defaultValue: () => axios\n            })\n            .addProp('responseToData', {\n                type: 'function',\n                defaultValue() {\n                    return noop;\n                },\n                required: true\n            })\n            .addProp('prepQuery', {\n                type: 'function',\n                defaultValue() {\n                    return noop;\n                },\n                required: false\n            })\n            .addProp('dataToClass', {\n                type: 'function',\n                defaultValue() {\n                    return noop;\n                },\n            })\n            .addProp('baseURL', {\n                type: 'string',\n                defaultValue: '/',\n                required: true,\n                test: [\n                    (value) => {\n                        if (value === '/') {\n                            return true;\n                        }\n                        return /$http(s)?:\\/\\/.+/.test(value);\n                    },\n                    false,\n                    'badly formed URL'\n                ]\n            });\n\n        return RestPool;\n    });\n};\n","export default bottle => {\n    bottle.factory('DataMap', () => {\n        return class DataMap {\n            constructor(records, pool) {\n                this._map = new Map();\n                this.pool = pool;\n                (Array.isArray(records) ? records : [records]).forEach(data => {\n                    const id = data[pool.idField];\n                    this.set(id, data);\n                })\n            }\n\n            get size() {\n                return this._map.size;\n            }\n\n            entries() {\n                return this._map.entries();\n            }\n\n            get(k){\n                return this._map.get(k);\n            }\n\n            set(...a) {\n                return this._map.set(...a);\n            }\n\n            has(k) {\n                return this._map.has(k);\n            }\n\n            keys() {\n                return this._map.keys()\n            }\n\n            clear() {\n                return this._map.clear()\n            }\n\n            delete(k) {\n                return this._map.delete(k)\n            }\n\n            values() {\n                return this._map.values()\n            }\n\n            forEach(fn) {\n                return this._map.forEach(fn)\n            }\n\n            overlaps(otherDataMap) {\n                if (!otherDataMap instanceof DataMap) {\n                    return false;\n                }\n                if (otherDataMap.size < this.size) {\n                    return otherDataMap.overlaps(this);\n                }\n                let keys = this.keys();\n                let next = keys.next();\n                while (!next.done) {\n                    if (otherDataMap.has(next.value)) {\n                        return true;\n                    }\n                    next = keys.next();\n                }\n\n                return false;\n            }\n\n            sharedKeys(otherDataMap) {\n                if (!otherDataMap instanceof DataMap) {\n                    return false;\n                }\n                if (otherDataMap.size < this.size) {\n                    return otherDataMap.sharedKeys(this);\n                }\n                let keys = this.keys();\n                let shared = [];\n                let next = keys.next();\n\n                while (!next.done) {\n                    if (otherDataMap.has(next.value)) {\n                        shared.push(next.value);\n                    }\n                    next = keys.next();\n                }\n\n                return shared;\n            }\n\n            clone(){\n                let dm = new DataMap([], this.pool);\n                dm.updateFrom(this, true);\n                return dm;\n            }\n\n            /**\n             * copy shared values from the other map into this one.\n             * @param otherMap\n             * @param useAll {bool}\n             * @param merge {bool} if true (default), new data is combined with old data. So fields can be added but not deleted.\n             */\n            updateFrom(otherMap, useAll = false, merge = true) {\n                if (otherMap.pool !== this.pool) {\n                    console.log(error('attempt to merge data from wrong pool', {\n                        map: this,\n                        otherMap\n                    }))\n                }\n\n                otherMap.forEach((value, key) => {\n                    if ((this.has(key))) {\n                        let merged = merge ? Object.assign({}, this.get(key), value): value;\n                        this.set(key, merged);\n                    } else if (useAll) {\n                        this.set(key, value);\n                    }\n                });\n                return this;\n            }\n        }\n    });\n}\n","import lGet from 'lodash.get';\nimport axios from 'axios';\nimport {filter, map} from 'rxjs/operators';\n\nexport default (bottle) => {\n    bottle.constant('REST_ACTIONS', 'get,put,post,delete,getAll'.split(','));\n\n    bottle.factory('axios', () => axios);\n\n    bottle.factory('mapForId', ({impulseRecordId}) => {\n        return (impulse) => {\n            const impulseId = impulse.id;\n            const ID = impulse.pool.identityField;\n\n            return signal => {\n\n                if (!signal) {\n                    console.log('!!!!!!!!!!!!!! mapForId -- no signal');\n                    return null;\n                }\n                const recordId = impulseRecordId(impulse);\n                let resultSignal = signal;\n\n                if (impulseId === resultSignal.impulse.id) {\n                    return resultSignal;\n                }\n\n                switch (signal.vector.name) {\n                    case 'put':\n                        break;\n\n                    case 'get':\n                        break;\n\n                    case 'delete':\n                        resultSignal = signal.mutate({response: null});\n                        break;\n\n                    case 'post':\n                        break;\n\n                    case 'getAll':\n                        if (!Array.isArray(signal.response)) {\n                            console.log('!!!!! signal not array response');\n                            return null;\n                        }\n                        let responses = signal.response.map((r) => {\n                            return r && (typeof r === 'object') && r[ID] === recordId;\n                        });\n                        const response = responses[0] || null;\n                        resultSignal = signal.mutate({response});\n                        break;\n\n                    default:\n                }\n\n                return resultSignal;\n            };\n        };\n    });\n\n    bottle.factory('impulseRecordId', ({UNSET, isUnset}) => {\n        return function impulseRecordId(impulse) {\n            try {\n                let recordId = UNSET;\n                const ID = impulse.pool.identityField;\n\n                if (impulse.vector.name === 'post') {\n                    if (isUnset(impulse.response)) {\n                        return false;\n                    }\n                    recordId = impulse.response[ID];\n                } else {\n                    const query = impulse.pool.impulseParamsToQuery(impulse.params, impulse);\n                    // the identity of the source impulse\n                    recordId = query.id;\n                }\n\n                return recordId;\n            } catch (err) {\n                console.log('!!!!!!!!! impulseRecordId -- error:', err);\n                return UNSET;\n            }\n        };\n    });\n\n    bottle.factory('filterForId', ({isUnset, impulseRecordId}) => {\n\n        return (impulse) => {\n            const impulseId = impulse.id;\n\n            return signal => {\n                if (!signal) {\n                    console.log('!!!!!!!!!!!!!! filterForId -- no signal');\n                    return false;\n                }\n                if (signal.impulse.id === impulseId) {\n                    return true;\n                }\n\n                let targetId = impulseRecordId(impulse);\n\n                let show = false;\n                let signalQuery;\n                switch (signal.vector.name) {\n                    case 'put':\n                        signalQuery = impulse.pool.impulseParamsToQuery(signal.impulse.params, signal.impulse, true);\n                        show = !isUnset(targetId) && (signalQuery.id === targetId);\n                        break;\n\n                    case 'get':\n                        signalQuery = impulse.pool.impulseParamsToQuery(signal.impulse.params, signal.impulse, true);\n                        show = !isUnset(targetId) && (signalQuery.id === targetId);\n                        break;\n\n                    case 'delete':\n                        signalQuery = impulse.pool.impulseParamsToQuery(signal.impulse.params, signal.impulse, true);\n                        show = !isUnset(targetId) && (signalQuery.id === targetId);\n                        break;\n\n                    case 'post':\n                        show = false;\n                        break;\n\n                    case 'getAll':\n                        show = true;\n                        break;\n\n                    default:\n                        show = false;\n\n                }\n                return show;\n            };\n        };\n    });\n\n    bottle.factory('restVectors', ({mapForId, filterForId}) => {\n\n        return {\n            get: {\n                sender(query, impulse) {\n                    const {pool} = impulse;\n                    return pool.connection.get(query.url, {headers: query.headers})\n                        .then(result => pool.responseToData(result, impulse));\n                },\n                paramsToQuery(params, impulse) {\n                    const {pool} = impulse;\n                    const query = pool.impulseParamsToQuery(params, impulse, true);\n                    return Object.assign({}, query, {\n                        url: pool.url(query.id, query.query)\n                    });\n                },\n                makeImpulseStream(impulse) {\n                    return impulse.pool.signalStream\n                        .pipe(\n                            filter(filterForId(impulse)),\n                            map(mapForId(impulse))\n                        );\n                },\n                idempotent: true,\n            },\n            getAll: {\n                sender(query, impulse) {\n                    const {pool} = impulse;\n                    return pool.connection.get(query.url, {headers: query.headers})\n                        .then(result => pool.responseToData(result, impulse));\n                },\n                paramsToQuery(params, impulse) {\n                    const {pool} = impulse;\n                    //  console.log('----------------paramsToQuery: impulse', impulse.toJSON(), '-------------pool:', pool.toJSON(), '------------ ');\n                    const query = pool.impulseParamsToQuery(params, impulse, true);\n                    return Object.assign({}, query, {\n                        url: pool.url('', query.query)\n                    });\n                },\n                makeImpulseStream(impulse) {\n                    return impulse.pool.signalStream\n                        .pipe(\n                            filter((signal) => {\n                                return signal.vector.name === 'getAll';\n                                // @TODO - integrate sub-updates\n                            })\n                        );\n                },\n                idempotent: true,\n            },\n\n            put: {\n                sender(query, impulse) {\n                    const {pool} = impulse;\n                    return pool.connection.put(query.url, query.data, {headers: query.headers})\n                        .then(result => pool.responseToData(result, impulse));\n                },\n                paramsToQuery(params, impulse) {\n                    const {pool} = impulse;\n                    const query = pool.impulseParamsToQuery(params, impulse, true);\n                    return Object.assign({}, query, {\n                        url: pool.url(query.id, query.query)\n                    });\n                },\n                makeImpulseStream(impulse) {\n                    return impulse.pool.signalStream\n                        .pipe(\n                            filter(filterForId(impulse)),\n                            map(mapForId(impulse))\n                        );\n                },\n\n                idempotent: false,\n            },\n\n            post: {\n                sender(query, impulse) {\n                    const {pool} = impulse;\n                    return pool.connection.post(query.url, query.data, {headers: query.headers})\n                        .then(result => pool.responseToData(result, impulse));\n                },\n                paramsToQuery(params, impulse) {\n                    const {pool} = impulse;\n                    const query = pool.impulseParamsToQuery(params, impulse, true);\n                    return Object.assign({}, query, {\n                        url: pool.url('', query.query)\n                    });\n                },\n                makeImpulseStream(impulse) {\n                    return impulse.pool.signalStream\n                        .pipe(\n                            filter(filterForId(impulse)),\n                            map(mapForId(impulse))\n                        );\n                },\n\n                idempotent: false,\n            },\n\n            delete: {\n                sender(query, impulse) {\n                    const {pool} = impulse;\n                    return pool.connection.delete(query.url, {headers: query.headers})\n                        .then(result => pool.responseToData(result, impulse));\n                },\n                paramsToQuery(params, impulse) {\n                    const {pool} = impulse;\n                    const query = pool.impulseParamsToQuery(params, impulse, true);\n                    return Object.assign({}, query,\n                        {url: pool.url(query.id, query.query)});\n                },\n                idempotent: false,\n            }\n        };\n    });\n\n    bottle.factory('impulseParamsToQuery', ({UNSET, isUnset}) => {\n        return (params, impulse, isSingle) => {\n            const {pool} = impulse;\n\n            let id = UNSET;\n            let data = UNSET;\n            let headers = {};\n            let query = {};\n\n            params.forEach((param) => {\n                if (!isSingle && Array.isArray(param) && isUnset(data)) {\n                    data = param;\n                } else if (typeof param === 'object') {\n                    if (isSingle && isUnset(data)) {\n                        data = param;\n                        if (pool.identityField in param) {\n                            id = lGet(param, pool.identityField);\n                        }\n                    } else {\n                        if ('headers' in param) {\n                            headers = param.headers;\n                        }\n                        if ('query' in param) {\n                            query = param.query;\n                        }\n                    }\n                } else if (isSingle && isUnset(id)) {\n                    id = param;\n                }\n            });\n\n            const out = {\n                id: (isUnset(id) ? '' : id), data: (isUnset(data) ? {} : data), headers, query\n            };\n\n            // console.log('impulseParamsToQuery, params:', params, 'single:', isSingle, 'impulse:', impulse.toJSON());\n            // console.log('----------------impulseParamsToQuery-result:', out);\n\n            return out;\n        };\n    });\n};\n","import lGet from 'lodash.get';\nimport uuid from 'uuid/v4';\n\nexport default (bottle) => {\n\n    bottle.factory('Signal', ({UNSET, Update, error, noop, isUnset}) => {\n        /**\n         * A channel is a named operation\n         */\n        return class Signal {\n            constructor(impulse, config = {}) {\n                this.id = uuid();\n                this.response = lGet(config, 'response', null);\n                this.error = lGet(config, 'error', null);\n                this._baseSignal = lGet(config, 'baseSignal', UNSET);\n                this._impulse = impulse;\n            }\n\n            toJSON() {\n                const out = {\n                    id: this.id,\n                    TYPE: 'SIGNAL',\n                    pool: this.pool.name,\n                    vector: this.vector.name,\n                    query: JSON.stringify(this.query),\n                    error: lGet(this, 'error', null),\n                    response: lGet(this, 'response', null),\n                    impulseId: this.impulse.id\n                };\n\n                if (!isUnset(this._baseSignal)){\n                    out.baseSignal = this._baseSignal.toJSON();\n                }\n\n                return out;\n            }\n\n            mutate(config) {\n                return new Signal(this.impulse, Object.assign({}, config, {  baseSignal: this}));\n            }\n\n            get baseSignal() {\n                return this._baseSignal;\n            }\n\n            get pool() {\n                return this.impulse.pool;\n            }\n\n            get impulse() {\n                return this._impulse;\n            }\n\n            get vector() {\n                return this.impulse.vector;\n            }\n\n            get params() {\n                return this.impulse.params;\n            }\n\n            get query() {\n                if (!this._query) {\n                    this._query = this.vector.paramsToQuery(this.impulse);\n                }\n                return this._query;\n            }\n        };\n    });\n};\n","import bottle from './bottle';\n\nconst myBottle = bottle();\nconst {\n    Pool,\n    RestPool,\n    Vector,\n    Impulse,\n    DataMap,\n    axios\n} = myBottle.container;\n\nexport default {\n    Pool,\n    RestPool,\n    Vector,\n    Impulse,\n    DataMap,\n    bottle,\n    axios\n}\n"],"names":["str","encodeURIComponent","replace","c","charCodeAt","toString","toUpperCase","getOwnPropertySymbols","Object","hasOwnProperty","prototype","propIsEnumerable","propertyIsEnumerable","assign","test1","String","getOwnPropertyNames","test2","i","fromCharCode","map","n","join","test3","split","forEach","letter","keys","err","shouldUseNative","target","source","from","symbols","to","val","TypeError","toObject","s","arguments","length","key","call","encode","value","opts","strict","strictUriEncode","RegExp","bottle","Bottle","factory","ref","Symbol","defaultValue","UNSET","item","string","name","msg","info","e","Error","unsetFactory","Vector","constructor","config","TYPE","pool","lGet","sender","schema","_makeImpulseStream","_paramsToQuery","noop","idempotent","impulse","params","Impulse","this","paramsToQuery","send","signal","body","recover","result","_this","query","response","isUnset","Promise","resolve","then","error","reject","makeImpulseStream","signalStream","pipe","filter","id","_signalStream","vector","subscribe","propper","addProp","type","required","onInvalid","field","object","collFactory","Pool","vectors","Map","addVector","force","has","set","get","Subject","toJSON","Array","poolFactory","constant","a","defaultCatcher","observable","mapper","catcher","switchMap","of","catchError","catchFactory","uuid","sent","_pending","catch","Signal","next","_completed","sub","_subs","push","__subs","complete","unsubscribe","paramsToID","test","firstQuery","impulseParamsToQuery","identity","signalToID","identityField","impulseFactory","_resolved","promise","done","fail","_done","_fail","resolved","args","listener","promiserFactory","RestPool","baseURL","prepQuery","responseToData","dataToClass","connection","axios","restActions","REST_ACTIONS","action","restVectors","isArray","url","queryParams","urlJoin","q","obj","objectAssign","arrayFormat","sort","formatter","index","encoderForArrayFormat","undefined","slice","val2","x","querystring","restPoolFactory","records","_map","data","idField","size","entries","k","clear","delete","values","fn","overlaps","otherDataMap","DataMap","sharedKeys","shared","clone","dm","updateFrom","otherMap","useAll","merge","console","log","merged","dataMapFactory","impulseId","ID","recordId","impulseRecordId","resultSignal","mutate","responses","r","signalQuery","targetId","show","headers","filterForId","mapForId","getAll","put","post","isSingle","param","restPoolUtilFactory","_baseSignal","_impulse","out","JSON","stringify","baseSignal","_query","signalFactory","container"],"mappings":"iVACiB,SAAUA,GAC1B,OAAOC,mBAAmBD,GAAKE,QAAQ,WAAY,SAAUC,GAC5D,MAAO,IAAMA,EAAEC,WAAW,GAAGC,SAAS,IAAIC,iBCKxCC,EAAwBC,OAAOD,sBAC/BE,EAAiBD,OAAOE,UAAUD,eAClCE,EAAmBH,OAAOE,UAAUE,uBAUxC,WACC,IACC,IAAKJ,OAAOK,OACX,OAAO,EAMR,IAAIC,EAAQ,IAAIC,OAAO,OAEvB,GADAD,EAAM,GAAK,KACkC,MAAzCN,OAAOQ,oBAAoBF,GAAO,GACrC,OAAO,EAKR,IADA,IAAIG,EAAQ,GACHC,EAAI,EAAGA,EAAI,GAAIA,IACvBD,EAAM,IAAMF,OAAOI,aAAaD,IAAMA,EAKvC,GAAwB,eAHXV,OAAOQ,oBAAoBC,GAAOG,IAAI,SAAUC,GAC5D,OAAOJ,EAAMI,KAEHC,KAAK,IACf,OAAO,EAIR,IAAIC,EAAQ,GAIZ,MAHA,uBAAuBC,MAAM,IAAIC,QAAQ,SAAUC,GAClDH,EAAMG,GAAUA,IAGf,yBADElB,OAAOmB,KAAKnB,OAAOK,OAAO,GAAIU,IAAQD,KAAK,IAM9C,MAAOM,GAER,OAAO,GAIQC,GAAoBrB,OAAOK,OAAS,SAAUiB,EAAQC,GAKtE,IAJA,IAAIC,EAEAC,EADAC,EAtDL,SAAkBC,GACjB,GAAIA,MAAAA,EACH,MAAM,IAAIC,UAAU,yDAGrB,OAAO5B,OAAO2B,GAiDLE,CAASP,GAGTQ,EAAI,EAAGA,EAAIC,UAAUC,OAAQF,IAAK,CAG1C,IAAK,IAAIG,KAFTT,EAAOxB,OAAO+B,UAAUD,IAGnB7B,EAAeiC,KAAKV,EAAMS,KAC7BP,EAAGO,GAAOT,EAAKS,IAIjB,GAAIlC,EAAuB,CAC1B0B,EAAU1B,EAAsByB,GAChC,IAAK,IAAId,EAAI,EAAGA,EAAIe,EAAQO,OAAQtB,IAC/BP,EAAiB+B,KAAKV,EAAMC,EAAQf,MACvCgB,EAAGD,EAAQf,IAAMc,EAAKC,EAAQf,MAMlC,OAAOgB,GCKR,SAASS,EAAOC,EAAOC,GACtB,OAAIA,EAAKF,OACDE,EAAKC,OAASC,EAAgBH,GAAS3C,mBAAmB2C,GAG3DA,EChGY,IAAII,OADZ,eAC0B,MACnB,IAAIA,OAAO,kBAAoB,MDsKlD,qBE3JQC,EAAS,IAAIC,SCdN,SAAsBD,GACjCA,EAAOE,QAAQ,iBAAUC,UAAaC,YAAO,WAC7CJ,EAAOE,QAAQ,mBAAYC,iCACfR,EAAOU,UACNV,IAAUW,QAA4B,IAAVX,EACtBU,EAEAV,KAKnBK,EAAOE,QAAQ,mBAAYC,iCACfI,UAASA,IAASD,KAG9BN,EAAOE,QAAQ,kBAAWC,mBACdK,UAAaC,KAAMD,MAG/BR,EAAOE,QAAQ,mCAAgBQ,EAAKC,OAC5BC,EAAI,IAAIC,MAAMH,UACdC,EACOpD,OAAOK,OAAOgD,EAAG,MAACD,IAEtBC,KDVXE,CAAad,YEVDA,GAEZA,EAAOE,QAAQ,kBAAWC,4DAIhBY,EACFC,SAAYP,EAAMQ,kBAAS,SAW3BC,KAAK,cAVIC,KAAOC,EAAKH,EAAQ,aACpBI,OAASD,EAAKH,EAAQ,eACtBA,OAASG,EAAKH,EAAQ,SAAUA,QAChCK,OAASF,EAAKH,EAAQ,eACtBM,mBAAqBH,EAAKH,EAAQ,oBAAqBX,QACvDkB,eAAiBJ,EAAKH,EAAQ,gBAAiBQ,QAC/CC,WAAaN,EAAKH,EAAQ,cAAc,QACxCR,KAAOA,yDAKhBkB,iBAAQC,yBAAS,IACN,IAAIC,EAAQ,QACPC,YACRF,iBAIRG,uBAAcJ,UACHG,KAAKN,eAAeG,EAAQC,OAAQD,EAASG,mBAGlDE,cAAKC,aAEqBH,YC8gBrC,SAAgBI,EAAMC,GAC5B,IACC,IAAIC,kBDhhBsCC,EAAKhB,OAAOY,EAAOK,MAAOL,4BAAlDA,EAAOM,WACDC,EAAQP,EAAON,QAAQY,cAClBZ,QAAQY,SAAWN,EAAOM,UAE9BE,QAAQC,QAAQT,KC6gBxC,MAAMrB,GACP,OAAOuB,EAAQvB,GAEhB,OAAIwB,GAAUA,EAAOO,KACbP,EAAOO,UAAK,EAAQR,GAErBC,cDlhBiBQ,UACLX,EAAOW,MAAQA,EACRH,QAAQI,OAAOZ,qDAI9Ba,2BAAkBnB,UACVa,EAAQV,KAAKP,oBAGJI,EAAQR,KACT4B,aAAaC,KAAKC,kBAAOhB,UAAUA,EAAON,QAAQuB,KAAOvB,EAAQuB,MAHlEpB,KAAKP,mBAAmBI,EAASG,SAM5CiB,8CACKjB,KAAKqB,qBACDA,cAAgBrB,KAAKX,KAAK4B,aAC1BC,KAAKC,kBAAOhB,UAAUA,EAAOmB,OAAO3C,OAASqB,EAAKrB,SAEpDqB,KAAKqB,2BAGhBE,uFACWvB,KAAKiB,cAAaM,gBAAUlD,EAAGyB,2CAI9C0B,EAAQvC,GACHwC,QAAQ,aAAc,CACnBC,KAAM,UACNnD,cAAc,IAEjBkD,QAAQ,OAAQ,CACbE,UAAU,EAAMD,KAAM,SACtBE,kFACUd,EAAM,kBAAmB,CAC3Be,MAAO,SACPC,OAAQ,cACRhC,OAIX2B,QAAQ,SAAU,CACfE,UAAU,EAAMD,KAAM,WACtBE,kFACUd,EAAM,oBAAqB,CAC7Be,MAAO,SACPC,OAAQ,cACRhC,OAIX2B,QAAQ,UACRA,QAAQ,SAAU,CACfC,KAAM,SACNE,kFACUd,EAAM,oBAAqB,CAC7Be,MAAO,SACPC,OAAQ,cACRhC,OAIX2B,QAAQ,OAAQ,CACbE,UAAU,EAAMD,KAAM,SACtBE,kFACUd,EAAM,kBAAmB,CAC3Be,MAAO,SACPC,OAAQ,cACRhC,OAKTb,IFrGX8C,CAAY7D,YIVAA,GAEZA,EAAOE,QAAQ,OAAQ,SAAUC,4BACvB2D,EACF9C,SAAYP,EAAMQ,kBAAS,SAClBR,KAAOA,OACPsD,QAAU3C,EAAKH,EAAQ,WAAY,IAAI+C,UACvC/C,OAASG,EAAKH,EAAQ,SAAUA,0DAGzCgD,mBAAUxD,EAAMQ,EAAQiD,sBAAQ,GACxBpC,KAAKiC,QAAQI,IAAI1D,KAAUyD,QACrBtB,EAAM,uBAAyBnC,EAAM,QACvCQ,OACAR,OACMqB,cAIVb,aAAkBF,GAClBE,EAAOE,KAAOW,UACTiC,QAAQK,IAAI3D,EAAMQ,SAElB8C,QAAQK,IAAI3D,EAAM,IAAIM,EAAON,EADT,mBAAXQ,EAC0B,MAAOa,YAAcb,GAErB1D,iBAAI0D,GAAQE,KAAMW,MAASb,KAEhEa,kBAGXH,iBAAQlB,qEACCqB,KAAKiC,QAAQI,IAAI1D,SACZmC,EAAM,wCAAyC,MAC3Cd,UACNrB,SACAmB,WAIDE,KAAKiC,QAAQM,IAAI5D,GAAMkB,QAAQC,MAGtCmB,mCACKjB,KAAKqB,qBACDA,cAAgB,IAAImB,WAEtBxC,KAAKqB,2BAGhBE,uFACWvB,KAAKiB,cAAaM,gBAAUlD,EAAGyB,gBAG1C2C,wBACW,CACH9D,KAAMqB,KAAKrB,UACL,OACNsD,QAASS,MAAMzF,KAAK+C,KAAKiC,QAAQrF,iDAK7C4E,EAAQQ,GACHP,QAAQ,UAAY,CAAClD,+BAAoB,IAAI2D,OAC7CT,QAAQ,OAAQ,CAACC,KAAM,SAAUC,UAAU,IAC3CF,QAAQ,SAAU,CACfC,KAAM,SAAUnD,8BACL,IAEXqD,kFACUd,EAAM,kBAAmB,CAC3Be,MAAO,SACPC,OAAQ,cACRhC,OAKTkC,IJnEXW,CAAYzE,GKdD,SAAsBA,GACnCA,EAAO0E,SAAS,gBAASC,UAAMA,QAEzBC,WAAkBjG,UAAUiE,MAAOjE,EAAKiG,gBAAgB,IAQ9D5E,EAAOE,QAAQ,mBAAYC,gCACjB0E,EAAYC,EAAeC,yBAANtD,kBAAgBmD,GACpCC,EAAW7B,KAChBgC,qBACEzC,UAAY0C,KAAG1C,GACZS,KACC7E,MAAI2G,GACJI,sBAAWtC,UAASqC,KAAGF,EAAQnC,aLHzCuC,CAAanF,YMbDA,GAEZA,EAAOE,QAAQ,6BAAsBC,UAAaC,YAAO,uBACzDJ,EAAOE,QAAQ,gCAAyBC,UAAaC,YAAO,0BAC5DJ,EAAOE,QAAQ,8BAAuBC,UAAaC,YAAO,wBAC1DJ,EAAOE,QAAQ,kCAA2BC,UAAaC,YAAO,4BAC9DJ,EAAOE,QAAQ,iCAA0BC,UAAaC,YAAO,2BAC7DJ,EAAOE,QAAQ,+BAAwBC,UAAaC,YAAO,yBAC3DJ,EAAOE,QAAQ,kCAA2BC,UAAaC,YAAO,4BAE9DJ,EAAOE,QAAQ,mBAAYC,kDAcb0B,EACFb,SAAYC,kBAAS,SACZiC,GAAKkC,SACLhC,OAAShC,EAAKH,EAAQ,eACtBW,OAASR,EAAKH,EAAQ,SAAUA,+FAGrCE,2BACOW,KAAKsB,OAAOjC,kBAGvBoD,wBACW,CACHrB,GAAIpB,KAAKoB,QACH,UACNE,OAAQtB,KAAKsB,OAAO3C,KACpBmB,OAAQE,KAAKF,OACbyD,KAAMvD,KAAKuD,KACX9C,SAAUT,KAAKS,uBAIvBP,8BACQF,KAAKwD,gBACDxD,KAAKsB,OAAO1B,WACLI,KAAKwD,SAELxD,KAAKwD,SACP3C,uBAAWb,EAAKE,SAChBuD,wBAAYzD,EAAKE,aAGpBC,EAAS,IAAIuD,EAAO1D,kBACrBwD,SAAWxD,KAAKsB,OAAOpB,KAAKC,GAC5BU,cAAMV,YACEqD,UAAW,EACZ9C,EAAQV,EAAKS,cACRA,SAAWN,EAAOM,YAEtBpB,KAAK4B,aAAa0C,KAAKxD,GACrBA,IAEVsD,0BACQD,UAAW,IACXnE,KAAK4B,aAAaH,MAAMX,GACtBA,SAEVoD,MAAO,EAGTvD,KAAKwD,YAGZvC,mCACKjB,KAAKqB,qBACDA,cAAgBrB,KAAKsB,OAAON,kBAAkBhB,OAEhDA,KAAKqB,2BAGhBE,iFACQvB,KAAK4D,iBACC9C,EAAM,wCAAyC,SACxCd,YAAMF,QAGjB+D,KAAM7D,KAAKiB,cAAaM,gBAAUlD,EAAGyB,eACtCgE,MAAMC,KAAKF,GACTA,KAGPC,4BACK9D,KAAKgE,cACDA,OAAS,IAEXhE,KAAKgE,oBAGhBC,yBACSL,YAAa,EACd5D,KAAKqB,oBACAA,cAAc4C,WAGnBjE,KAAKgE,aACAA,OAAOtH,iBAAQa,UAAKA,EAAE2G,uBAGxBlE,KAAKgE,oBAMhBG,yBACQ,oBAAoBC,KAAKpE,KAAKsB,OAAO3C,MAAO,KACtC0F,EAAarE,KAAKX,KAAKiF,qBAAqBtE,MAC5CU,EAAQ2D,EAAWjD,IAAwB,KAAlBiD,EAAWjD,WACjCmD,SAAWF,EAAWjD,kBAKvCoD,oBAAWrE,GACHA,EAAON,QAAQuB,KAAOpB,KAAKoB,IAG3BjB,EAAOM,UAAwC,iBAApBN,EAAOM,gBAC7B8D,SAAWpE,EAAOM,SAAST,KAAKX,KAAKoF,wDAMtDjD,EAAQzB,GACH0B,QAAQ,SAAU,CACfC,KAAM,QACNC,UAAU,IAEbF,QAAQ,WAAY,CACjBlD,+BAAoBC,KAEvBiD,QAAQ,OAAQ,CACbC,KAAM,UACNnD,cAAc,IAEjBkD,QAAQ,SAAU,CACfE,UAAU,EACVD,KAAM,SACNE,mBACK/E,SACSiE,EAAM,qBAAsB,CAC9Be,MAAO,SACPC,OAAQ,cACRjF,OAKbkD,INrJf2E,CAAexG,YOnBHA,GAEZA,EAAOE,QAAQ,oBAAaC,qBAEpBa,6BACSyF,WAAY,OACZC,QAAU,IAAIjE,iBAASkE,EAAMC,KACzBC,MAAQF,IACRG,MAAQF,gDAIjBG,+BACOjF,KAAK2E,uBAchB/D,iBAAQH,UACAT,KAAKiF,SACEjF,KAAK4E,cAGXnE,SAAWA,OAEXkE,WAAY,OACZI,MAAMtE,GACJT,KAAK4E,sBAGhB7D,gBAAOD,UACCd,KAAKiF,SACEjF,KAAK4E,cAGXD,WAAY,OAEZ7D,MAAQA,OAERkE,MAAMhF,MACJA,KAAK4E,sBAGhB/D,kFACWb,KAAK4E,SAAQ/D,WAAKxC,EAAG6G,gBAGhCzB,eAAM0B,UACKnF,KAAK4E,QAAQnB,MAAM0B,kDPrCtCC,CAAgBlH,YQbJA,GAEZA,EAAOE,QAAQ,oBAAaC,oHAKlBgH,cACFnG,WAAYP,EAAMQ,0BACRR,EAAMQ,QACPmG,QAAUhG,EAAKH,EAAQ,UAAW,UAClCoG,UAAYjG,EAAKH,EAAQ,YAAa,WACtCsF,cAAgBnF,EAAKH,EAAQ,gBAAiB,WAC9CqG,eAAiBlG,EAAKH,EAAQ,iBAAkBQ,QAChD8F,YAAcnG,EAAKH,EAAQ,cAAeQ,QAC1C+F,WAAapG,EAAKH,EAAQ,aAAcwG,QACxCrB,qBAAuBhF,EAAKH,EAAQ,uBAAwBmF,OAE7DsB,EAActG,EAAKH,EAAQ,cAAeX,GAC1CkC,EAAQkF,GACRC,EAAanJ,iBAASoJ,KACb3D,UAAU2D,EAAQC,EAAYD,MAGvCF,EAAYlJ,iBAASoJ,MACK,iBAAXA,IACF3D,UAAU2D,EAAQC,EAAYD,QAChC,CAAA,IAAIpD,MAAMsD,QAAQF,SAIfhF,EAAM,2BAA6BnC,EAAM,QAACmH,MAF3C3D,wHAQrBM,wBACW,CACH9D,KAAMqB,KAAKrB,KACXS,KAAM,WACNkG,QAAStF,KAAKsF,QACdrD,QAASS,MAAMzF,KAAK+C,KAAKiC,QAAQrF,sBAIzCqJ,aAAI7E,EAAI8E,OACAD,EAAc,KAAP7E,GAAaV,EAAQU,GAAOpB,KAAKsF,QAAUa,EAAQnG,KAAKsF,QAASlE,GACtEgF,EVqHF,SAAUC,EAAKvI,IAShB,KAFlBA,EAAOwI,EANQ,CACd1I,QAAQ,EACRG,QAAQ,EACRwI,YAAa,QAGgBzI,IAErB0I,OACR1I,EAAK0I,KAAO,cAGb,IAAIC,EApLL,SAA+B3I,GAC9B,OAAQA,EAAKyI,aACZ,IAAK,QACJ,OAAO,SAAU7I,EAAKG,EAAO6I,GAC5B,OAAiB,OAAV7I,EAAiB,CACvBD,EAAOF,EAAKI,GACZ,IACA4I,EACA,KACCnK,KAAK,IAAM,CACZqB,EAAOF,EAAKI,GACZ,IACAF,EAAO8I,EAAO5I,GACd,KACAF,EAAOC,EAAOC,IACbvB,KAAK,KAGT,IAAK,UACJ,OAAO,SAAUmB,EAAKG,GACrB,OAAiB,OAAVA,EAAiBD,EAAOF,EAAKI,GAAQ,CAC3CF,EAAOF,EAAKI,GACZ,MACAF,EAAOC,EAAOC,IACbvB,KAAK,KAGT,QACC,OAAO,SAAUmB,EAAKG,GACrB,OAAiB,OAAVA,EAAiBD,EAAOF,EAAKI,GAAQ,CAC3CF,EAAOF,EAAKI,GACZ,IACAF,EAAOC,EAAOC,IACbvB,KAAK,MAmJMoK,CAAsB7I,GAEtC,OAAOuI,EAAM5K,OAAOmB,KAAKyJ,GAAKG,KAAK1I,EAAK0I,MAAMnK,IAAI,SAAUqB,GAC3D,IAAIN,EAAMiJ,EAAI3I,GAEd,QAAYkJ,IAARxJ,EACH,MAAO,GAGR,GAAY,OAARA,EACH,OAAOQ,EAAOF,EAAKI,GAGpB,GAAI4E,MAAMsD,QAAQ5I,GAAM,CACvB,IAAIkD,EAAS,GAUb,OARAlD,EAAIyJ,QAAQnK,QAAQ,SAAUoK,QAChBF,IAATE,GAIJxG,EAAOyD,KAAK0C,EAAU/I,EAAKoJ,EAAMxG,EAAO7C,WAGlC6C,EAAO/D,KAAK,KAGpB,OAAOqB,EAAOF,EAAKI,GAAQ,IAAMF,EAAOR,EAAKU,KAC3CqD,OAAO,SAAU4F,GACnB,OAAOA,EAAEtJ,OAAS,IAChBlB,KAAK,KAAO,GUhKWyK,CAAsBd,UAC7BE,IACAH,GAAO,IAAMG,GAGVH,qBAIfzE,EAAQ6D,GACH5D,QAAQ,gBAAiB,CACtBC,KAAM,SACNC,UAAU,EACVpD,aAAc,OAEjBkD,QAAQ,aAAc,CACnBE,UAAU,EACVpD,+BAAoBoH,KAEvBlE,QAAQ,iBAAkB,CACvBC,KAAM,WACNnD,+BACWoB,GAEXgC,UAAU,IAEbF,QAAQ,YAAa,CAClBC,KAAM,WACNnD,+BACWoB,GAEXgC,UAAU,IAEbF,QAAQ,cAAe,CACpBC,KAAM,WACNnD,+BACWoB,KAGd8B,QAAQ,UAAW,CAChBC,KAAM,SACNnD,aAAc,IACdoD,UAAU,EACVyC,KAAM,UACDvG,SACiB,MAAVA,GAGG,mBAAmBuG,KAAKvG,KAEnC,EACA,sBAILwH,IRzFX4B,CAAgB/I,YSrBLA,GACXA,EAAOE,QAAQ,uCAEPc,WAAYgI,EAAS7H,mBACZ8H,KAAO,IAAIjF,SACX7C,KAAOA,GACXqD,MAAMsD,QAAQkB,GAAWA,EAAU,CAACA,IAAUxK,iBAAQ0K,KAE9C9E,IADM8E,EAAK/H,EAAKgI,SACRD,6CAIjBE,2BACOtH,KAAKmH,KAAKG,kBAGrBC,0BACWvH,KAAKmH,KAAKI,uBAGrBhF,aAAIiF,UACOxH,KAAKmH,KAAK5E,IAAIiF,gBAGzBlF,iFACWtC,KAAKmH,MAAK7E,UAAIjE,EAAGwE,gBAG5BR,aAAImF,UACOxH,KAAKmH,KAAK9E,IAAImF,gBAGzB5K,uBACWoD,KAAKmH,KAAKvK,oBAGrB6K,wBACWzH,KAAKmH,KAAKM,qBAGrBC,gBAAOF,UACIxH,KAAKmH,KAAKO,OAAOF,gBAG5BG,yBACW3H,KAAKmH,KAAKQ,sBAGrBjL,iBAAQkL,UACG5H,KAAKmH,KAAKzK,QAAQkL,gBAG7BC,kBAASC,OACAA,aAAwBC,SAClB,KAEPD,EAAaR,KAAOtH,KAAKsH,YAClBQ,EAAaD,SAAS7H,cAE7BpD,EAAOoD,KAAKpD,OACZ+G,EAAO/G,EAAK+G,QACRA,EAAKkB,MAAM,IACXiD,EAAazF,IAAIsB,EAAK9F,cACf,EAEX8F,EAAO/G,EAAK+G,cAGT,eAGXqE,oBAAWF,OACFA,aAAwBC,SAClB,KAEPD,EAAaR,KAAOtH,KAAKsH,YAClBQ,EAAaE,WAAWhI,cAE/BpD,EAAOoD,KAAKpD,OACZqL,EAAS,GACTtE,EAAO/G,EAAK+G,QAERA,EAAKkB,MACLiD,EAAazF,IAAIsB,EAAK9F,QACtBoK,EAAOlE,KAAKJ,EAAK9F,OAErB8F,EAAO/G,EAAK+G,cAGTsE,eAGXC,qBACQC,EAAK,IAAIJ,EAAQ,GAAI/H,KAAKX,aAC9B8I,EAAGC,WAAWpI,MAAM,GACbmI,eASXC,oBAAWC,EAAUC,EAAgBC,qCAAP,mBAAe,GACrCF,EAAShJ,OAASW,KAAKX,MACvBmJ,QAAQC,IAAI3H,MAAM,wCAAyC,CACvDzE,IAAK2D,cACLqI,KAIRA,EAAS3L,iBAASmB,EAAOH,MAChBsC,EAAKqC,IAAI3E,GAAO,KACbgL,EAASH,EAAQ9M,OAAOK,OAAO,GAAIkE,EAAKuC,IAAI7E,GAAMG,GAAQA,IACzDyE,IAAI5E,EAAKgL,QACPJ,KACFhG,IAAI5E,EAAKG,KAGfmC,oDTlGnB2I,CAAezK,YUlBHA,GACZA,EAAO0E,SAAS,eAAgB,6BAA6BnG,MAAM,MAEnEyB,EAAOE,QAAQ,0BAAeuH,IAE9BzH,EAAOE,QAAQ,oBAAaC,2CAChBwB,OACE+I,EAAY/I,EAAQuB,GACpByH,EAAKhJ,EAAQR,KAAKoF,8BAEjBtE,OAEEA,SACDqI,QAAQC,IAAI,wCACL,SAELK,EAAWC,EAAgBlJ,GAC7BmJ,EAAe7I,KAEfyI,IAAcI,EAAanJ,QAAQuB,UAC5B4H,SAGH7I,EAAOmB,OAAO3C,UACb,UAGA,gBAGA,SACDqK,EAAe7I,EAAO8I,OAAO,CAACxI,SAAU,iBAGvC,iBAGA,aACIiC,MAAMsD,QAAQ7F,EAAOM,iBACtB+H,QAAQC,IAAI,mCACL,SAEPS,EAAY/I,EAAOM,SAASpE,aAAK8M,UAC1BA,GAAmB,iBAANA,GAAmBA,EAAEN,KAAQC,IAGrDE,EAAe7I,EAAO8I,OAAO,UADZC,EAAU,IAAM,cAOlCF,MAKnB9K,EAAOE,QAAQ,2BAAoBC,oCACxB,SAAyBwB,WAEpBiJ,EAAWtK,EACTqK,EAAKhJ,EAAQR,KAAKoF,iBAEI,SAAxB5E,EAAQyB,OAAO3C,KAAiB,IAC5B+B,EAAQb,EAAQY,iBACT,EAEXqI,EAAWjJ,EAAQY,SAASoI,QAI5BC,EAFcjJ,EAAQR,KAAKiF,qBAAqBzE,EAAQC,OAAQD,GAE/CuB,UAGd0H,EACT,MAAOjM,UACL2L,QAAQC,IAAI,sCAAuC5L,GAC5C2B,MAKnBN,EAAOE,QAAQ,uBAAgBC,uDAEnBwB,OACE+I,EAAY/I,EAAQuB,mBAEnBjB,OACEA,SACDqI,QAAQC,IAAI,4CACL,KAEPtI,EAAON,QAAQuB,KAAOwH,SACf,MAMPQ,EAHAC,EAAWN,EAAgBlJ,GAE3ByJ,GAAO,SAEHnJ,EAAOmB,OAAO3C,UACb,UAKA,UAKA,SACDyK,EAAcvJ,EAAQR,KAAKiF,qBAAqBnE,EAAON,QAAQC,OAAQK,EAAON,SAAS,GACvFyJ,GAAQ5I,EAAQ2I,IAAcD,EAAYhI,KAAOiI,YAGhD,OACDC,GAAO,YAGN,SACDA,GAAO,gBAIPA,GAAO,SAGRA,MAKnBpL,EAAOE,QAAQ,uBAAgBC,0CAEpB,CACHkE,IAAK,CACDhD,gBAAOiB,EAAOX,GACHR,oBACAA,EAAKqG,WAAWnD,IAAI/B,EAAMyF,IAAK,CAACsD,QAAS/I,EAAM+I,UACjD1I,cAAKP,UAAUjB,EAAKmG,eAAelF,EAAQT,MAEpDI,uBAAcH,EAAQD,GACXR,aACDmB,EAAQnB,EAAKiF,qBAAqBxE,EAAQD,GAAS,UAClDpE,OAAOK,OAAO,GAAI0E,EAAO,CAC5ByF,IAAK5G,EAAK4G,IAAIzF,EAAMY,GAAIZ,EAAMA,UAGtCQ,2BAAkBnB,UACPA,EAAQR,KAAK4B,aACfC,KACGC,SAAOqI,EAAY3J,IACnBxD,MAAIoN,EAAS5J,MAGzBD,YAAY,GAEhB8J,OAAQ,CACJnK,gBAAOiB,EAAOX,GACHR,oBACAA,EAAKqG,WAAWnD,IAAI/B,EAAMyF,IAAK,CAACsD,QAAS/I,EAAM+I,UACjD1I,cAAKP,UAAUjB,EAAKmG,eAAelF,EAAQT,MAEpDI,uBAAcH,EAAQD,GACXR,aAEDmB,EAAQnB,EAAKiF,qBAAqBxE,EAAQD,GAAS,UAClDpE,OAAOK,OAAO,GAAI0E,EAAO,CAC5ByF,IAAK5G,EAAK4G,IAAI,GAAIzF,EAAMA,UAGhCQ,2BAAkBnB,UACPA,EAAQR,KAAK4B,aACfC,KACGC,kBAAQhB,SAC0B,WAAvBA,EAAOmB,OAAO3C,SAKrCiB,YAAY,GAGhB+J,IAAK,CACDpK,gBAAOiB,EAAOX,GACHR,oBACAA,EAAKqG,WAAWiE,IAAInJ,EAAMyF,IAAKzF,EAAM4G,KAAM,CAACmC,QAAS/I,EAAM+I,UAC7D1I,cAAKP,UAAUjB,EAAKmG,eAAelF,EAAQT,MAEpDI,uBAAcH,EAAQD,GACXR,aACDmB,EAAQnB,EAAKiF,qBAAqBxE,EAAQD,GAAS,UAClDpE,OAAOK,OAAO,GAAI0E,EAAO,CAC5ByF,IAAK5G,EAAK4G,IAAIzF,EAAMY,GAAIZ,EAAMA,UAGtCQ,2BAAkBnB,UACPA,EAAQR,KAAK4B,aACfC,KACGC,SAAOqI,EAAY3J,IACnBxD,MAAIoN,EAAS5J,MAIzBD,YAAY,GAGhBgK,KAAM,CACFrK,gBAAOiB,EAAOX,GACHR,oBACAA,EAAKqG,WAAWkE,KAAKpJ,EAAMyF,IAAKzF,EAAM4G,KAAM,CAACmC,QAAS/I,EAAM+I,UAC9D1I,cAAKP,UAAUjB,EAAKmG,eAAelF,EAAQT,MAEpDI,uBAAcH,EAAQD,GACXR,aACDmB,EAAQnB,EAAKiF,qBAAqBxE,EAAQD,GAAS,UAClDpE,OAAOK,OAAO,GAAI0E,EAAO,CAC5ByF,IAAK5G,EAAK4G,IAAI,GAAIzF,EAAMA,UAGhCQ,2BAAkBnB,UACPA,EAAQR,KAAK4B,aACfC,KACGC,SAAOqI,EAAY3J,IACnBxD,MAAIoN,EAAS5J,MAIzBD,YAAY,GAGhB8H,OAAQ,CACJnI,gBAAOiB,EAAOX,GACHR,oBACAA,EAAKqG,WAAWgC,OAAOlH,EAAMyF,IAAK,CAACsD,QAAS/I,EAAM+I,UACpD1I,cAAKP,UAAUjB,EAAKmG,eAAelF,EAAQT,MAEpDI,uBAAcH,EAAQD,GACXR,aACDmB,EAAQnB,EAAKiF,qBAAqBxE,EAAQD,GAAS,UAClDpE,OAAOK,OAAO,GAAI0E,EACrB,CAACyF,IAAK5G,EAAK4G,IAAIzF,EAAMY,GAAIZ,EAAMA,UAEvCZ,YAAY,MAKxB1B,EAAOE,QAAQ,gCAAyBC,6CAC5ByB,EAAQD,EAASgK,GACdxK,aAEH+B,EAAK5C,EACL4I,EAAO5I,EACP+K,EAAU,GACV/I,EAAQ,UAEZV,EAAOpD,iBAASoN,IACPD,GAAYnH,MAAMsD,QAAQ8D,IAAUpJ,EAAQ0G,GAC7CA,EAAO0C,EACiB,iBAAVA,EACVD,GAAYnJ,EAAQ0G,IACpBA,EAAO0C,EACHzK,EAAKoF,iBAAiBqF,IACtB1I,EAAK9B,EAAKwK,EAAOzK,EAAKoF,kBAGtB,YAAaqF,IACbP,EAAUO,EAAMP,SAEhB,UAAWO,IACXtJ,EAAQsJ,EAAMtJ,QAGfqJ,GAAYnJ,EAAQU,KAC3BA,EAAK0I,KAID,CACR1I,GAAKV,EAAQU,GAAM,GAAKA,EAAKgG,KAAO1G,EAAQ0G,GAAQ,GAAKA,UAAOmC,QAAS/I,MVtQrFuJ,CAAoB7L,YWpBRA,GAEZA,EAAOE,QAAQ,kBAAWC,+CAKlBa,WAAYW,EAASV,kBAAS,SACrBiC,GAAKkC,SACL7C,SAAWnB,EAAKH,EAAQ,WAAY,WACpC2B,MAAQxB,EAAKH,EAAQ,QAAS,WAC9B6K,YAAc1K,EAAKH,EAAQ,aAAcX,QACzCyL,SAAWpK,qLAGpB4C,sBACUyH,EAAM,CACR9I,GAAIpB,KAAKoB,GACThC,KAAM,SACNC,KAAMW,KAAKX,KAAKV,KAChB2C,OAAQtB,KAAKsB,OAAO3C,KACpB6B,MAAO2J,KAAKC,UAAUpK,KAAKQ,OAC3BM,MAAOxB,EAAKU,KAAM,QAAS,MAC3BS,SAAUnB,EAAKU,KAAM,WAAY,MACjC4I,UAAW5I,KAAKH,QAAQuB,WAGvBV,EAAQV,KAAKgK,eACdE,EAAIG,WAAarK,KAAKgK,YAAYvH,UAG/ByH,eAGXjB,gBAAO9J,UACI,IAAIuE,EAAO1D,KAAKH,QAASpE,OAAOK,OAAO,GAAIqD,EAAQ,CAAGkL,WAAYrK,WAGzEqK,iCACOrK,KAAKgK,eAGZ3K,2BACOW,KAAKH,QAAQR,QAGpBQ,8BACOG,KAAKiK,YAGZ3I,6BACOtB,KAAKH,QAAQyB,UAGpBxB,6BACOE,KAAKH,QAAQC,UAGpBU,4BACKR,KAAKsK,cACDA,OAAStK,KAAKsB,OAAOrB,cAAcD,KAAKH,UAE1CG,KAAKsK,sDXzCxBC,CAAcrM,GACPA,KYvBMA,IAQJsM,yBAEE,4FAMXtM"}