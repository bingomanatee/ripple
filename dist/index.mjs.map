{"version":3,"file":"index.mjs","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../node_modules/strict-uri-encode/index.js","../node_modules/object-assign/index.js","../node_modules/query-string/index.js","../node_modules/decode-uri-component/index.js","../src/bottle.js","../src/utils.js","../src/Vector.js","../src/Pool.js","../src/rxCatch.js","../src/Impulse.js","../src/RestPool.js","../src/RestPoolUtils.js","../src/Signal.js","../src/index.js"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && !check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, value);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\t_entry(_this).then(returnValue, function(error) {\n\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","'use strict';\nmodule.exports = function (str) {\n\treturn encodeURIComponent(str).replace(/[!'()*]/g, function (c) {\n\t\treturn '%' + c.charCodeAt(0).toString(16).toUpperCase();\n\t});\n};\n","/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n","'use strict';\nvar strictUriEncode = require('strict-uri-encode');\nvar objectAssign = require('object-assign');\nvar decodeComponent = require('decode-uri-component');\n\nfunction encoderForArrayFormat(opts) {\n\tswitch (opts.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn function (key, value, index) {\n\t\t\t\treturn value === null ? [\n\t\t\t\t\tencode(key, opts),\n\t\t\t\t\t'[',\n\t\t\t\t\tindex,\n\t\t\t\t\t']'\n\t\t\t\t].join('') : [\n\t\t\t\t\tencode(key, opts),\n\t\t\t\t\t'[',\n\t\t\t\t\tencode(index, opts),\n\t\t\t\t\t']=',\n\t\t\t\t\tencode(value, opts)\n\t\t\t\t].join('');\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn function (key, value) {\n\t\t\t\treturn value === null ? encode(key, opts) : [\n\t\t\t\t\tencode(key, opts),\n\t\t\t\t\t'[]=',\n\t\t\t\t\tencode(value, opts)\n\t\t\t\t].join('');\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn function (key, value) {\n\t\t\t\treturn value === null ? encode(key, opts) : [\n\t\t\t\t\tencode(key, opts),\n\t\t\t\t\t'=',\n\t\t\t\t\tencode(value, opts)\n\t\t\t\t].join('');\n\t\t\t};\n\t}\n}\n\nfunction parserForArrayFormat(opts) {\n\tvar result;\n\n\tswitch (opts.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn function (key, value, accumulator) {\n\t\t\t\tresult = /\\[(\\d*)\\]$/.exec(key);\n\n\t\t\t\tkey = key.replace(/\\[\\d*\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = {};\n\t\t\t\t}\n\n\t\t\t\taccumulator[key][result[1]] = value;\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn function (key, value, accumulator) {\n\t\t\t\tresult = /(\\[\\])$/.exec(key);\n\t\t\t\tkey = key.replace(/\\[\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t} else if (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = [value];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn function (key, value, accumulator) {\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\t}\n}\n\nfunction encode(value, opts) {\n\tif (opts.encode) {\n\t\treturn opts.strict ? strictUriEncode(value) : encodeURIComponent(value);\n\t}\n\n\treturn value;\n}\n\nfunction keysSorter(input) {\n\tif (Array.isArray(input)) {\n\t\treturn input.sort();\n\t} else if (typeof input === 'object') {\n\t\treturn keysSorter(Object.keys(input)).sort(function (a, b) {\n\t\t\treturn Number(a) - Number(b);\n\t\t}).map(function (key) {\n\t\t\treturn input[key];\n\t\t});\n\t}\n\n\treturn input;\n}\n\nfunction extract(str) {\n\tvar queryStart = str.indexOf('?');\n\tif (queryStart === -1) {\n\t\treturn '';\n\t}\n\treturn str.slice(queryStart + 1);\n}\n\nfunction parse(str, opts) {\n\topts = objectAssign({arrayFormat: 'none'}, opts);\n\n\tvar formatter = parserForArrayFormat(opts);\n\n\t// Create an object with no prototype\n\t// https://github.com/sindresorhus/query-string/issues/47\n\tvar ret = Object.create(null);\n\n\tif (typeof str !== 'string') {\n\t\treturn ret;\n\t}\n\n\tstr = str.trim().replace(/^[?#&]/, '');\n\n\tif (!str) {\n\t\treturn ret;\n\t}\n\n\tstr.split('&').forEach(function (param) {\n\t\tvar parts = param.replace(/\\+/g, ' ').split('=');\n\t\t// Firefox (pre 40) decodes `%3D` to `=`\n\t\t// https://github.com/sindresorhus/query-string/pull/37\n\t\tvar key = parts.shift();\n\t\tvar val = parts.length > 0 ? parts.join('=') : undefined;\n\n\t\t// missing `=` should be `null`:\n\t\t// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n\t\tval = val === undefined ? null : decodeComponent(val);\n\n\t\tformatter(decodeComponent(key), val, ret);\n\t});\n\n\treturn Object.keys(ret).sort().reduce(function (result, key) {\n\t\tvar val = ret[key];\n\t\tif (Boolean(val) && typeof val === 'object' && !Array.isArray(val)) {\n\t\t\t// Sort object keys, not values\n\t\t\tresult[key] = keysSorter(val);\n\t\t} else {\n\t\t\tresult[key] = val;\n\t\t}\n\n\t\treturn result;\n\t}, Object.create(null));\n}\n\nexports.extract = extract;\nexports.parse = parse;\n\nexports.stringify = function (obj, opts) {\n\tvar defaults = {\n\t\tencode: true,\n\t\tstrict: true,\n\t\tarrayFormat: 'none'\n\t};\n\n\topts = objectAssign(defaults, opts);\n\n\tif (opts.sort === false) {\n\t\topts.sort = function () {};\n\t}\n\n\tvar formatter = encoderForArrayFormat(opts);\n\n\treturn obj ? Object.keys(obj).sort(opts.sort).map(function (key) {\n\t\tvar val = obj[key];\n\n\t\tif (val === undefined) {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (val === null) {\n\t\t\treturn encode(key, opts);\n\t\t}\n\n\t\tif (Array.isArray(val)) {\n\t\t\tvar result = [];\n\n\t\t\tval.slice().forEach(function (val2) {\n\t\t\t\tif (val2 === undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tresult.push(formatter(key, val2, result.length));\n\t\t\t});\n\n\t\t\treturn result.join('&');\n\t\t}\n\n\t\treturn encode(key, opts) + '=' + encode(val, opts);\n\t}).filter(function (x) {\n\t\treturn x.length > 0;\n\t}).join('&') : '';\n};\n\nexports.parseUrl = function (str, opts) {\n\treturn {\n\t\turl: str.split('?')[0] || '',\n\t\tquery: parse(extract(str), opts)\n\t};\n};\n","'use strict';\nvar token = '%[a-f0-9]{2}';\nvar singleMatcher = new RegExp(token, 'gi');\nvar multiMatcher = new RegExp('(' + token + ')+', 'gi');\n\nfunction decodeComponents(components, split) {\n\ttry {\n\t\t// Try to decode the entire string first\n\t\treturn decodeURIComponent(components.join(''));\n\t} catch (err) {\n\t\t// Do nothing\n\t}\n\n\tif (components.length === 1) {\n\t\treturn components;\n\t}\n\n\tsplit = split || 1;\n\n\t// Split the array in 2 parts\n\tvar left = components.slice(0, split);\n\tvar right = components.slice(split);\n\n\treturn Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n}\n\nfunction decode(input) {\n\ttry {\n\t\treturn decodeURIComponent(input);\n\t} catch (err) {\n\t\tvar tokens = input.match(singleMatcher);\n\n\t\tfor (var i = 1; i < tokens.length; i++) {\n\t\t\tinput = decodeComponents(tokens, i).join('');\n\n\t\t\ttokens = input.match(singleMatcher);\n\t\t}\n\n\t\treturn input;\n\t}\n}\n\nfunction customDecodeURIComponent(input) {\n\t// Keep track of all the replacements and prefill the map with the `BOM`\n\tvar replaceMap = {\n\t\t'%FE%FF': '\\uFFFD\\uFFFD',\n\t\t'%FF%FE': '\\uFFFD\\uFFFD'\n\t};\n\n\tvar match = multiMatcher.exec(input);\n\twhile (match) {\n\t\ttry {\n\t\t\t// Decode as big chunks as possible\n\t\t\treplaceMap[match[0]] = decodeURIComponent(match[0]);\n\t\t} catch (err) {\n\t\t\tvar result = decode(match[0]);\n\n\t\t\tif (result !== match[0]) {\n\t\t\t\treplaceMap[match[0]] = result;\n\t\t\t}\n\t\t}\n\n\t\tmatch = multiMatcher.exec(input);\n\t}\n\n\t// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n\treplaceMap['%C2'] = '\\uFFFD';\n\n\tvar entries = Object.keys(replaceMap);\n\n\tfor (var i = 0; i < entries.length; i++) {\n\t\t// Replace all decoded components\n\t\tvar key = entries[i];\n\t\tinput = input.replace(new RegExp(key, 'g'), replaceMap[key]);\n\t}\n\n\treturn input;\n}\n\nmodule.exports = function (encodedURI) {\n\tif (typeof encodedURI !== 'string') {\n\t\tthrow new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\n\t}\n\n\ttry {\n\t\tencodedURI = encodedURI.replace(/\\+/g, ' ');\n\n\t\t// Try the built in decoder first\n\t\treturn decodeURIComponent(encodedURI);\n\t} catch (err) {\n\t\t// Fallback to a more advanced decoder\n\t\treturn customDecodeURIComponent(encodedURI);\n\t}\n};\n","import Bottle from 'bottlejs';\n\nimport collFactory from './Vector';\nimport poolFactory from './Pool';\nimport impulseFactory from './Impulse';\nimport catchFactory from './rxCatch';\nimport unsetFactory from './utils';\nimport restPoolFactory from './RestPool';\nimport restPoolUtilFactory from './RestPoolUtils';\nimport signalFactory from './Signal';\n\nexport default () => {\n  let bottle = new Bottle();\n\n  unsetFactory(bottle);\n  collFactory(bottle);\n  poolFactory(bottle);\n  catchFactory(bottle);\n  impulseFactory(bottle);\n  restPoolFactory(bottle);\n  restPoolUtilFactory(bottle);\n  signalFactory(bottle);\n  return bottle;\n};\n","export default function unsetFactory(bottle) {\n  bottle.factory('UNSET', ({ Symbol }) => Symbol('UNSET'));\n  bottle.factory('ifUnset', ({ UNSET }) => {\n    return (value, defaultValue) => {\n      if ((value === UNSET) || (typeof value === 'undefined')) {\n        return defaultValue;\n      }\n      return value;\n\n    };\n  });\n\n  bottle.factory('isUnset', ({ UNSET }) => {\n    return (item) => item === UNSET;\n  });\n\n  bottle.factory('Symbol', () => {\n    return (string) => ({ 'name': string });\n  });\n\n  bottle.factory('error', () => (msg, info) => {\n    let e = new Error(msg);\n\n    if (info) {\n      return Object.assign(e, { info });\n    }\n    return e;\n  });\n}\n","import propper from '@wonderlandlabs/propper';\nimport lGet from 'lodash.get';\nimport { filter } from 'rxjs/operators';\n\nexport default (bottle) => {\n\n  bottle.factory('Vector', ({ UNSET, Impulse, error, noop, isUnset }) => {\n    /**\n         * A channel is a named operation\n         */\n    class Vector {\n      constructor(name, sender, pool, config = {}) {\n        this.sender = sender;\n        this.pool = pool;\n        this.config = lGet(config, 'config', config);\n        this.schema = lGet(config, 'schema');\n        this._makeImpulseStream = lGet(config, 'makeImpulseStream', UNSET);\n        this._paramsToQuery = lGet(config, 'paramsToQuery', noop);\n        this.idempotent = lGet(config, 'idempotent', false);\n        this.name = name;\n      }\n\n      impulse(params = {}) {\n        return new Impulse({\n          'vector': this,\n          params\n        });\n      }\n\n      paramsToQuery(impulse) {\n        return this._paramsToQuery(impulse.params, impulse, this);\n      }\n\n      async send(signal) {\n        try {\n          signal.response = await this.sender(signal.query, signal);\n          if (!(isUnset(signal.impulse.response))) {\n            signal.impulse.response = signal.response;\n          }\n          return Promise.resolve(signal);\n        } catch (err) {\n          signal.error = err;\n          return Promise.reject(signal);\n        }\n      }\n\n      makeImpulseStream(impulse) {\n        if (!isUnset(this._makeImpulseStream)) {\n          return this._makeImpulseStream(impulse, this);\n        }\n        const pool = impulse.pool;\n\n        return pool.signalStream.pipe(filter((signal) => signal.impulse.id === impulse.id));\n      }\n\n      get signalStream() {\n        if (!this._signalStream) {\n          this._signalStream = this.pool.signalStream\n            .pipe(filter((signal) => signal.vector.name === this.name));\n        }\n        return this._signalStream;\n      }\n\n      subscribe(...params) {\n        return this.signalStream.subscribe(...params);\n      }\n    }\n\n    propper(Vector)\n      .addProp('idempotent', {\n        'type': 'boolean',\n        'defaultValue': false\n      })\n      .addProp('pool', {\n        'required': true, 'type': 'object',\n        'onInvalid': (...params) => {\n          throw error('bad vector.pool', {\n            'field': 'config',\n            'object': 'Pool',\n            params\n          });\n        }\n      })\n      .addProp('sender', {\n        'required': true, 'type': 'function',\n        'onInvalid': (...params) => {\n          throw error('bad vector.sender', {\n            'field': 'config',\n            'object': 'Pool',\n            params\n          });\n        }\n      })\n      .addProp('schema')\n      .addProp('config', {\n        'type': 'object',\n        'onInvalid': (...params) => {\n          throw error('bad vector.config', {\n            'field': 'config',\n            'object': 'Pool',\n            params\n          });\n        }\n      })\n      .addProp('name', {\n        'required': true, 'type': 'string',\n        'onInvalid': (...params) => {\n          throw error('bad vector.name', {\n            'field': 'config',\n            'object': 'Pool',\n            params\n          });\n        }\n      });\n\n    return Vector;\n  });\n};\n","import { Subject } from 'rxjs';\nimport lGet from 'lodash.get';\nimport propper from '@wonderlandlabs/propper';\n\nexport default (bottle) => {\n\n  bottle.factory('Pool', ({ Vector, error }) => {\n    class Pool {\n      constructor(name, config = {}) {\n        this.name = name;\n        this.vectors = lGet(config, '_vectors', new Map());\n        this.vectors.forEach((v) => {\n          v.pool = this;\n        });\n        this.config = lGet(config, 'config', config);\n      }\n\n      addVector(name, sender, config, force = false) {\n        if (this.vectors.has(name) && !force) {\n          throw error(`Attempt to redefine ${name}`, {\n            config,\n            name,\n            'pool': this\n          });\n        }\n\n        if (sender instanceof Vector) {\n          sender.pool = this;\n          this.vectors.set(name, sender);\n        } else {\n          this.vectors.set(name, new Vector(name, sender, this, config));\n        }\n        return this;\n      }\n\n      impulse(name, ...params) {\n        if (!this.vectors.has(name)) {\n          throw error('attempt to use an unregistered vector', {\n            'pool': this,\n            name,\n            params\n          });\n        }\n\n        return this.vectors.get(name).impulse(params);\n      }\n\n      get signalStream() {\n        if (!this._signalStream) {\n          this._signalStream = new Subject();\n        }\n        return this._signalStream;\n      }\n\n      subscribe(...params) {\n        return this.signalStream.subscribe(...params);\n      }\n\n      toJSON() {\n        return {\n          'name': this.name,\n          'TYPE': 'POOL',\n          'vectors': Array.from(this.vectors.keys())\n        };\n      }\n    }\n\n    propper(Pool)\n      .addProp('vectors', ({ 'defaultValue': () => new Map() }))\n      .addProp('name', { 'type': 'string', 'required': true })\n      .addProp('config', {\n        'type': 'object', 'defaultValue': () => {\n          return {};\n        },\n        'onInvalid': (...params) => {\n          throw error('bad pool.config', {\n            'field': 'config',\n            'object': 'Pool',\n            params\n          });\n        }\n      });\n\n    return Pool;\n  });\n};\n","import { catchError, map, switchMap } from 'rxjs/operators';\nimport { of } from 'rxjs';\n\nexport default function catchFactory(bottle) {\n  bottle.constant('noop', (a) => a);\n\n  const defaultCatcher = (err) => ({ 'error': err, 'defaultCatcher': true });\n\n  /**\n   * Maps the output to a function that can throw errors.\n   * Re-maps error output to the catcher function.\n   * The resulting subscriber has pseudo-promise syntax\n   * that lets you set the mapper\n   */\n  bottle.factory('rxCatch', ({ noop }) => {\n    return (observable, mapper = noop, catcher = defaultCatcher) => {\n      return observable.pipe(\n        switchMap(\n          (response) => of(response)\n            .pipe(\n              map(mapper),\n              catchError((error) => of(catcher(error))))\n        ));\n    };\n  });\n}\n","import lGet from 'lodash.get';\nimport uuid from 'uuid/v4';\nimport propper from '@wonderlandlabs/propper';\n\nexport default (bottle) => {\n\n  bottle.factory('IMPULSE_STATE_NEW', ({ Symbol }) => Symbol('IMPULSE_STATE_NEW'));\n  bottle.factory('IMPULSE_STATE_QUEUED', ({ Symbol }) => Symbol('IMPULSE_STATE_QUEUED'));\n  bottle.factory('IMPULSE_STATE_SENT', ({ Symbol }) => Symbol('IMPULSE_STATE_SENT'));\n  bottle.factory('IMPULSE_STATE_RESOLVED', ({ Symbol }) => Symbol('IMPULSE_STATE_RESOLVED'));\n  bottle.factory('IMPULSE_STATE_UPDATED', ({ Symbol }) => Symbol('IMPULSE_STATE_UPDATED'));\n  bottle.factory('IMPULSE_STATE_ERROR', ({ Symbol }) => Symbol('IMPULSE_STATE_ERROR'));\n  bottle.factory('IMPULSE_STATE_COMPLETE', ({ Symbol }) => Symbol('IMPULSE_STATE_COMPLETE'));\n\n  bottle.factory('Impulse', ({\n    UNSET, error, Signal, isUnset\n  }) => {\n\n    /**\n             * An impulse is a single call to a channel.\n             * It exists for an indefinate period before it is performed,\n             * so it can be used as a \"draft\" or prepared query that you\n             * build up and send.\n             *\n             * Once set, its response subscribes to the pools updates\n             * stream so that it can change (or present warnings) when\n             * the pool's other impulse updates are relevant to the response.\n             */\n    class Impulse {\n      constructor(config = {}) {\n        this.id = uuid();\n        this.vector = lGet(config, 'vector');\n        this.params = lGet(config, 'params', config);\n      }\n\n      get pool() {\n        return this.vector.pool;\n      }\n\n      toJSON() {\n        return {\n          'id': this.id,\n          'TYPE': 'Impulse',\n          'vector': this.vector.name,\n          'params': this.params,\n          'sent': this.sent,\n          'response': this.response\n        };\n      }\n\n      send() {\n        if (this._pending) {\n          if (this.vector.idempotent) {\n            return this._pending;\n          }\n          return this._pending\n            .then(() => this.send())\n            .catch(() => this.send());\n\n        }\n        const signal = new Signal(this);\n\n        this._pending = this.vector.send(signal)\n          .then((sigResponse) => {\n            this._pending = false;\n            if (isUnset(this.response)) {\n              this.response = sigResponse.response;\n            }\n            this.pool.signalStream.next(sigResponse);\n            return sigResponse;\n          })\n          .catch(() => {\n            this._pending = false;\n            this.pool.signalStream.error(signal);\n            return signal;\n          });\n        this.sent = true;\n\n\n        return this._pending;\n      }\n\n      get signalStream() {\n        if (!this._signalStream) {\n          this._signalStream = this.vector.makeImpulseStream(this);\n        }\n        return this._signalStream;\n      }\n\n      subscribe(...params) {\n        if (this._completed) {\n          throw error('cannot subscribe to completed impulse', {\n            'impulse': this, params\n          });\n        }\n        const sub = this.signalStream.subscribe(...params);\n\n        this._subs.push(sub);\n        return sub;\n      }\n\n      get _subs() {\n        if (!this.__subs) {\n          this.__subs = [];\n        }\n        return this.__subs;\n      }\n\n      complete() {\n        this._completed = true;\n        if (this._signalStream) {\n          this._signalStream.complete();\n        }\n\n        if (this.__subs) {\n          this.__subs.forEach((s) => s.unsubscribe());\n        }\n\n        delete this.__subs;\n      }\n\n      /**\n                 * Get the identity property of the impulse's parameters.\n                 */\n      paramsToID() {\n        if (/(get|post|delete)/.test(this.vector.name)) {\n          const firstQuery = this.pool.impulseParamsToQuery(this);\n\n          if (!(isUnset(firstQuery.id || firstQuery.id === ''))) {\n            this.identity = firstQuery.id;\n          }\n        }\n      }\n\n      signalToID(signal) {\n        if (signal.impulse.id !== this.id) {\n          return;\n        }\n        if (signal.response && (typeof signal.response === 'object')) {\n          this.identity = signal.response[ this.pool.identityField ];\n        }\n      }\n    }\n\n\n    propper(Impulse)\n      .addProp('params', {\n        'type': 'array',\n        'required': true\n      })\n      .addProp('response', {\n        'defaultValue': () => UNSET\n      })\n      .addProp('sent', {\n        'type': 'boolean',\n        'defaultValue': false\n      })\n      .addProp('vector', {\n        'required': true,\n        'type': 'object',\n        'onInvalid':\n                        (err) => {\n                          throw error('bad impulse.config', {\n                            'field': 'vector',\n                            'object': 'Impulse',\n                            err\n                          });\n                        }\n      });\n\n    return Impulse;\n  }\n  );\n};\n","import lGet from 'lodash.get';\nimport urlJoin from 'url-join';\nimport querystring from 'query-string';\nimport propper from '@wonderlandlabs/propper';\n\nexport default (bottle) => {\n\n  bottle.factory('RestPool', ({\n    Pool, error, isUnset, noop, axios, UNSET,\n    REST_ACTIONS, restVectors, impulseParamsToQuery\n  }) => {\n\n    class RestPool extends Pool {\n      constructor(name, config) {\n        super(name, config);\n        this.baseURL = lGet(config, 'baseURL', '/');\n        this.prepQuery = lGet(config, 'prepQuery', null);\n        this.identityField = lGet(config, 'identityField', 'id');\n        this.responseToData = lGet(config, 'responseToData', noop);\n        this.connection = lGet(config, 'connection', axios);\n        this.impulseParamsToQuery = lGet(config, 'impulseParamsToQuery', impulseParamsToQuery);\n\n        let restActions = lGet(config, 'restActions', UNSET);\n\n        if (isUnset(restActions)) {\n          REST_ACTIONS.forEach((action) => {\n            let actionConfig = Object.assign({}, restVectors[ action ]);\n            const sender = actionConfig.sender;\n\n            delete actionConfig.sender;\n            this.addVector(action, sender, actionConfig);\n          });\n        } else {\n          restActions.forEach((action) => {\n            if (typeof action === 'string') {\n              let actionConfig = Object.assign({}, restVectors[ action ]);\n              const sender = config.sender;\n\n              delete actionConfig.sender;\n              this.addVector(action, sender, actionConfig);\n            } else if (Array.isArray(actionConfig)) {\n              this.addVector(...actionConfig);\n            } else {\n              throw error(`strange action for pool ${ name}`, { 'action': actionConfig });\n            }\n          });\n        }\n      }\n\n      toJSON() {\n        return {\n          'name': this.name,\n          'TYPE': 'RestPool',\n          'baseURL': this.baseURL,\n          'vectors': Array.from(this.vectors.keys())\n        };\n      }\n\n      url(id, queryParams) {\n        let url = (id === '' || isUnset(id)) ? this.baseURL : urlJoin(this.baseURL, id);\n        const q = querystring.stringify(queryParams);\n\n        if (q) {\n          url += `?${ q}`;\n        }\n        // console.log('url from ', this.baseURL, 'id =', id, 'queryParams = ', queryParams, '=', url);\n        return url;\n      }\n    }\n\n    propper(RestPool)\n      .addProp('identityField', {\n        'type': 'string',\n        'required': true,\n        'defaultValue': 'id'\n      })\n      .addProp('connection', {\n        'required': true,\n        'defaultValue': () => axios\n      })\n      .addProp('responseToData', {\n        'type': 'function',\n        defaultValue() {\n          return noop;\n        },\n        'required': true\n      })\n      .addProp('prepQuery', {\n        'type': 'function',\n        defaultValue() {\n          return noop;\n        },\n        'required': false\n      })\n      .addProp('baseURL', {\n        'type': 'string',\n        'defaultValue': '/',\n        'required': true,\n        'test': [\n          (value) => {\n            if (value === '/') {\n              return true;\n            }\n            return /$http(s)?:\\/\\/.+/.test(value);\n          },\n          false,\n          'badly formed URL'\n        ]\n      });\n\n    return RestPool;\n  });\n};\n","import lGet from 'lodash.get';\nimport axios from 'axios';\nimport lEqual from 'lodash.isequal';\nimport { filter, map, distinctUntilChanged } from 'rxjs/operators';\n\nexport default (bottle) => {\n  bottle.constant('REST_ACTIONS', 'get,put,post,delete,getAll'.split(','));\n\n  bottle.factory('axios', () => axios);\n\n  bottle.factory('mapForId', ({ impulseRecordId }) => {\n    return (impulse) => {\n      const impulseId = impulse.id;\n      const ID = impulse.pool.identityField;\n\n      return (signal) => {\n        if (!signal) {\n          console.log('!!!!!!!!!!!!!! mapForId -- no signal');\n          return null;\n        }\n        const recordId = impulseRecordId(impulse);\n        let responses; let response; let resultSignal = signal;\n\n        if (impulseId === resultSignal.impulse.id) {\n          return resultSignal;\n        }\n\n        switch (signal.vector.name) {\n          case 'put':\n            break;\n\n          case 'get':\n            break;\n\n          case 'delete':\n            resultSignal = signal.mutate({ 'response': null });\n            break;\n\n          case 'post':\n            break;\n\n          case 'getAll':\n            if (!Array.isArray(signal.response)) {\n              console.log('!!!!! signal not array response');\n              return null;\n            }\n            responses = signal.response.map((r) => {\n              return r && (typeof r === 'object') && r[ ID ] === recordId;\n            });\n            response = responses[ 0 ] || null;\n\n            resultSignal = signal.mutate({ response });\n            break;\n\n          default:\n        }\n\n        return resultSignal;\n      };\n    };\n  });\n\n  bottle.factory('impulseRecordId', ({ UNSET, isUnset }) => {\n    return function impulseRecordId(impulse) {\n      try {\n        let recordId = UNSET;\n        const ID = impulse.pool.identityField;\n\n        if (impulse.vector.name === 'post') {\n          if (isUnset(impulse.response)) {\n            return false;\n          }\n          recordId = impulse.response[ ID ];\n        } else {\n          const query = impulse.pool.impulseParamsToQuery(impulse.params, impulse);\n          // the identity of the source impulse\n\n          recordId = query.id;\n        }\n\n        return recordId;\n      } catch (err) {\n        console.log('!!!!!!!!! impulseRecordId -- error:', err);\n        return UNSET;\n      }\n    };\n  });\n\n  bottle.factory('filterForId', ({ isUnset, impulseRecordId }) => {\n\n    return (impulse) => {\n      const impulseId = impulse.id;\n\n      return (signal) => {\n        if (!signal) {\n          console.log('!!!!!!!!!!!!!! filterForId -- no signal');\n          return false;\n        }\n        if (signal.impulse.id === impulseId) {\n          return true;\n        }\n\n        let targetId = impulseRecordId(impulse);\n        let ID = impulse.pool.identityField;\n\n        let show = false;\n        let signalQuery;\n\n        switch (signal.vector.name) {\n          case 'put':\n            signalQuery = impulse.pool.impulseParamsToQuery(signal.impulse.params, signal.impulse);\n            show = !isUnset(targetId) && (signalQuery.id === targetId);\n            break;\n\n          case 'get':\n            signalQuery = impulse.pool.impulseParamsToQuery(signal.impulse.params, signal.impulse);\n            show = !isUnset(targetId) && (signalQuery.id === targetId);\n            break;\n\n          case 'delete':\n            signalQuery = impulse.pool.impulseParamsToQuery(signal.impulse.params, signal.impulse);\n            show = !isUnset(targetId) && (signalQuery.id === targetId);\n            break;\n\n          case 'post':\n            show = false;\n            break;\n\n          case 'getAll':\n            show = signal.response.filter((r) => r[ ID ] === targetId).length;\n            break;\n\n          default:\n            show = false;\n\n        }\n        return show;\n      };\n    };\n  });\n\n  bottle.factory('compareResponse', ({}) => {\n    /**\n         * this is a factory that returns a function suitable for use in distinctUntilChanged.\n         * note the comparator returns true if the elements are equal\n         * and false if they are not -- and false is when the record will be emitted.\n         */\n    return (s1, s2) => {\n      const response1 = s1.response;\n      const response2 = s2.response;\n\n      return lEqual(response1, response2);\n    };\n  });\n\n  bottle.factory('restVectors', ({ mapForId, filterForId, compareResponse }) => {\n\n    return {\n      'get': {\n        sender(query, impulse) {\n          const { pool } = impulse;\n          const config = { ...query };\n\n          delete config.url;\n          delete config.query;\n          delete config.id;\n\n          return pool.connection.get(query.url, config)\n            .then((result) => pool.responseToData(result, impulse));\n        },\n        paramsToQuery(params, impulse) {\n          const { pool } = impulse;\n          const query = pool.impulseParamsToQuery(params, impulse, true);\n\n          return Object.assign({}, query, {\n            'url': pool.url(query.id, query.query)\n          });\n        },\n        makeImpulseStream(impulse) {\n          return impulse.pool.signalStream\n            .pipe(\n              filter(filterForId(impulse)),\n              map(mapForId(impulse)),\n              distinctUntilChanged(compareResponse)\n            );\n        },\n        'idempotent': true\n      },\n      'getAll': {\n        sender(query, impulse) {\n          const { pool } = impulse;\n          const config = { ...query };\n\n          delete config.url;\n          delete config.query;\n          delete config.id;\n\n          return pool.connection.get(query.url, config)\n            .then((result) => pool.responseToData(result, impulse));\n        },\n        paramsToQuery(params, impulse) {\n          const { pool } = impulse;\n\n          //  console.log('----------------paramsToQuery: impulse', impulse.toJSON(), '-------------pool:', pool.toJSON(), '------------ ');\n          const config = pool.impulseParamsToQuery(params, impulse, false);\n          const { query } = config;\n\n          return Object.assign({}, config, {\n            'url': pool.url('', query)\n          });\n        },\n        makeImpulseStream(impulse) {\n          return impulse.pool.signalStream\n            .pipe(\n              filter((signal) => {\n                return signal.vector.name === 'getAll' && lEqual(signal.impulse.params, impulse.params);\n                // @TODO - integrate sub-updates\n              })\n            );\n          // note - NO distinctUntilChanged - too expensive to compare large arrays, always returning.\n        },\n        'idempotent': true\n      },\n\n      'put': {\n        sender(query, impulse) {\n          const { pool } = impulse;\n          const config = { ...query };\n          const body = lGet(query, 'body', {});\n\n          delete config.url;\n          delete config.query;\n          delete config.id;\n          delete config.body;\n\n          return pool.connection.put(query.url, body, config)\n            .then((result) => pool.responseToData(result, impulse));\n        },\n        paramsToQuery(params, impulse) {\n          const { pool } = impulse;\n          const query = pool.impulseParamsToQuery(params, impulse, true);\n\n          return Object.assign({}, query, {\n            'url': pool.url(query.id, query.query)\n          });\n        },\n        makeImpulseStream(impulse) {\n          return impulse.pool.signalStream\n            .pipe(\n              filter(filterForId(impulse)),\n              map(mapForId(impulse)),\n              distinctUntilChanged(compareResponse)\n            );\n        },\n\n        'idempotent': false\n      },\n\n      'post': {\n        sender(query, impulse) {\n          const { pool } = impulse;\n\n          const config = { ...query };\n          const body = lGet(query, 'body', {});\n\n          delete config.url;\n          delete config.query;\n          delete config.id;\n          delete config.body;\n\n          return pool.connection.post(query.url, body, config)\n            .then((result) => pool.responseToData(result, impulse));\n        },\n        paramsToQuery(params, impulse) {\n          const { pool } = impulse;\n          const query = pool.impulseParamsToQuery(params, impulse, true);\n\n          return Object.assign({}, query, {\n            'url': pool.url('', query.query)\n          });\n        },\n        makeImpulseStream(impulse) {\n          return impulse.pool.signalStream\n            .pipe(\n              filter(filterForId(impulse)),\n              map(mapForId(impulse)),\n              distinctUntilChanged(compareResponse)\n            );\n        },\n\n        'idempotent': false\n      },\n\n      'delete': {\n        sender(query, impulse) {\n          const { pool } = impulse;\n          const config = { ...query };\n\n          delete config.url;\n          delete config.query;\n          delete config.id;\n          delete config.body;\n\n          return pool.connection.delete(query.url, config)\n            .then((result) => pool.responseToData(result, impulse));\n        },\n        paramsToQuery(params, impulse) {\n          const { pool } = impulse;\n          const query = pool.impulseParamsToQuery(params, impulse, true);\n\n          return Object.assign({}, query,\n            { 'url': pool.url(query.id, query.query) });\n        },\n        // the default impulse stream -- only listens to itself -- is fine.\n        'idempotent': false\n      }\n    };\n  });\n\n  /**\n   * this method expects an array\n   * [id, body, config]\n   * or [config]\n   * but NOT [id, config];\n   * use [id, null, config] instead.\n   */\n  bottle.factory('impulseParamsToQuery', () => {\n    return (params, impulse) => {\n      const out = {};\n\n      if (params.length > 0) {\n        const [ id, body, config ] = params;\n\n        if (id && (typeof id === 'object')) {\n          Object.assign(out, id);\n        } else {\n          if (config && (typeof config === 'object')) {\n            Object.assign(out, config);\n          }\n\n          if (!(body === null || !body)) {\n            out.body = body;\n          }\n\n          if (!(id === null || id === '')) {\n            out.id = id;\n          }\n        }\n      }\n      console.log('imageParamsToQuery');\n      return out;\n    };\n  });\n};\n","import lGet from 'lodash.get';\nimport uuid from 'uuid/v4';\n\nexport default (bottle) => {\n\n  bottle.factory('Signal', ({ UNSET, isUnset }) => {\n    /**\n         * A channel is a named operation\n         */\n    return class Signal {\n      constructor(impulse, config = {}) {\n        this.id = uuid();\n        this.response = lGet(config, 'response', null);\n        this.error = lGet(config, 'error', null);\n        this._baseSignal = lGet(config, 'baseSignal', UNSET);\n        this._impulse = impulse;\n      }\n\n      toJSON() {\n        const out = {\n          'id': this.id,\n          'TYPE': 'SIGNAL',\n          'pool': this.pool.name,\n          'vector': this.vector.name,\n          'query': JSON.stringify(this.query),\n          'error': lGet(this, 'error', null),\n          'response': lGet(this, 'response', null),\n          'impulseId': this.impulse.id\n        };\n\n        if (!isUnset(this._baseSignal)) {\n          out.baseSignal = this._baseSignal.toJSON();\n        }\n\n        return out;\n      }\n\n      mutate(config) {\n        return new Signal(this.impulse, Object.assign({}, config, { 'baseSignal': this }));\n      }\n\n      get baseSignal() {\n        return this._baseSignal;\n      }\n\n      get pool() {\n        return this.impulse.pool;\n      }\n\n      get impulse() {\n        return this._impulse;\n      }\n\n      get vector() {\n        return this.impulse.vector;\n      }\n\n      get params() {\n        return this.impulse.params;\n      }\n\n      get query() {\n        if (!this._query) {\n          this._query = this.vector.paramsToQuery(this.impulse);\n        }\n        return this._query;\n      }\n    };\n  });\n};\n","import bottle from './bottle';\n\nconst myBottle = bottle();\nconst {\n  Pool,\n  RestPool,\n  Vector,\n  Impulse,\n  DataMap,\n  axios\n} = myBottle.container;\n\nexport default {\n  Pool,\n  RestPool,\n  Vector,\n  Impulse,\n  DataMap,\n  bottle,\n  axios\n};\n"],"names":["Symbol","iterator","asyncIterator","str","encodeURIComponent","replace","c","charCodeAt","toString","toUpperCase","getOwnPropertySymbols","Object","hasOwnProperty","prototype","propIsEnumerable","propertyIsEnumerable","assign","test1","String","getOwnPropertyNames","test2","i","fromCharCode","map","n","join","test3","split","forEach","letter","keys","err","shouldUseNative","target","source","from","symbols","to","val","TypeError","toObject","s","arguments","length","key","call","encode","value","opts","strict","strictUriEncode","RegExp","bottle","Bottle","factory","ref","defaultValue","UNSET","item","string","msg","info","e","Error","unsetFactory","Vector","constructor","name","sender","pool","config","lGet","schema","_makeImpulseStream","_paramsToQuery","noop","idempotent","impulse","params","Impulse","this","paramsToQuery","send","signal","body","recover","result","_this","query","response","isUnset","Promise","resolve","then","error","reject","makeImpulseStream","signalStream","pipe","filter","id","_signalStream","vector","subscribe","propper","addProp","collFactory","Pool","vectors","Map","v","addVector","force","has","set","get","Subject","toJSON","Array","poolFactory","constant","a","defaultCatcher","observable","mapper","catcher","switchMap","of","catchError","catchFactory","uuid","sent","_pending","catch","Signal","sigResponse","next","_completed","sub","_subs","push","__subs","complete","unsubscribe","paramsToID","test","firstQuery","impulseParamsToQuery","identity","signalToID","identityField","impulseFactory","RestPool","baseURL","prepQuery","responseToData","connection","axios","restActions","REST_ACTIONS","action","actionConfig","restVectors","isArray","url","queryParams","urlJoin","q","obj","objectAssign","arrayFormat","sort","formatter","index","encoderForArrayFormat","undefined","slice","val2","x","querystring","restPoolFactory","impulseId","ID","console","log","responses","recordId","impulseRecordId","resultSignal","mutate","r","signalQuery","targetId","show","s1","s2","lEqual","filterForId","mapForId","distinctUntilChanged","compareResponse","put","post","delete","out","restPoolUtilFactory","_baseSignal","_impulse","JSON","stringify","baseSignal","_query","signalFactory","container"],"mappings":"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"}