{"version":3,"file":"index.umd.js","sources":["../src/bottle.js","../src/utils.js","../src/Vector.js","../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/Pool.js","../src/rxCatch.js","../src/Impulse.js","../src/Promiser.js","../src/RestPool.js","../src/DataMap.js","../src/RestPoolUtils.js","../src/Signal.js","../src/index.js"],"sourcesContent":["import Bottle from 'bottlejs';\n\nimport collFactory from './Vector';\nimport poolFactory from './Pool';\nimport impulseFactory from './Impulse';\nimport catchFactory from './rxCatch';\nimport promiserFactory from './Promiser';\nimport unsetFactory from './utils';\nimport restPoolFactory from './RestPool';\nimport restPoolUtilFactory from './RestPoolUtils';\nimport dataMapFactory from './DataMap';\nimport signalFactory from './Signal';\n\nexport default () => {\n    let bottle = new Bottle();\n    unsetFactory(bottle);\n    collFactory(bottle);\n    poolFactory(bottle);\n    catchFactory(bottle);\n    impulseFactory(bottle);\n    promiserFactory(bottle);\n    restPoolFactory(bottle);\n    dataMapFactory(bottle);\n    restPoolUtilFactory(bottle);\n    signalFactory(bottle);\n    return bottle;\n}\n","export default function unsetFactory(bottle) {\n    bottle.factory('UNSET', ({Symbol}) => Symbol('UNSET'));\n    bottle.factory('ifUnset', ({UNSET}) => {\n        return (value, defaultValue) => {\n            if ((value === UNSET) || (typeof value === \"undefined\")) {\n                return defaultValue;\n            } else {\n                return value;\n            }\n        }\n    });\n\n    bottle.factory('isUnset', ({UNSET}) => {\n        return (item) => item === UNSET;\n    });\n\n    bottle.factory('Symbol', ({noop}) => {\n        return (string) => ({name: string});\n    });\n\n    bottle.factory('error', () => (msg, info) => {\n        let e = new Error(msg);\n        if (info) {\n            return Object.assign(e, {info})\n        }\n        return e;\n    });\n}\n","import propper from '@wonderlandlabs/propper';\nimport lGet from 'lodash.get';\nimport {filter, map, startWith} from 'rxjs/operators';\nimport uuid from 'uuid/v4';\n\nexport default (bottle) => {\n\n    bottle.factory('Vector', ({UNSET, Update, Impulse, error, noop, isUnset}) => {\n        /**\n         * A channel is a named operation\n         */\n        class Vector {\n            constructor(name, config = {}) {\n                this.pool = lGet(config, 'pool');\n                this.sender = lGet(config, 'sender');\n                this.config = lGet(config, 'config', config);\n                this.schema = lGet(config, 'schema');\n                this._impulseFilter = lGet(config, 'impulseFilter', UNSET);\n                this._impulseMap = lGet(config, 'impulseMap', UNSET);\n                this._paramsToQuery = lGet(config, 'paramsToQuery', noop);\n                this.idempotent = lGet(config, 'idempotent', false)\n                this.name = name;\n            }\n\n            impulse(params = {}) {\n                return new Impulse({\n                    vector: this,\n                    params\n                })\n            }\n\n            paramsToQuery(impulse) {\n                return this._paramsToQuery(impulse.params, impulse, this);\n            }\n\n            async send(signal) {\n                try {\n                    signal.response = await this.sender(signal.query, signal);\n                    return Promise.resolve(signal);\n                } catch (error) {\n                    signal.error = error;\n                    return Promise.reject(signal);\n                }\n            }\n\n            impulseFilter(impulse) {\n                const id = impulse.id;\n                return isUnset(this._impulseFilter) ? (signal => signal.impulse.id === id)\n                    : this._impulseFilter(impulse, this);\n            }\n\n            impulseMap(impulse) {\n                return isUnset(this._impulseMap) ? noop\n                    : this._impulseMap(impulse, this);\n            }\n\n            get signalStream() {\n                if (!this._signalStream) {\n                    this._signalStream = this.pool.signalStream\n                        .pipe(filter(signal => signal.vector.name === this.name));\n                }\n                return this._signalStream;\n            }\n\n            subscribe(...params) {\n                return this.signalStream.subscribe(...params);\n            }\n        };\n\n        propper(Vector)\n            .addProp('idempotent', {\n                type: 'boolean',\n                defaultValue: false\n            })\n            .addProp('pool', {\n                required: true, type: 'object',\n                onInvalid: (...params) => {\n                    throw error('bad vector.pool', {\n                        field: 'config',\n                        object: 'Pool',\n                        params\n                    })\n                }\n            })\n            .addProp('sender', {\n                required: true, type: 'function',\n                onInvalid: (...params) => {\n                    throw error('bad vector.sender', {\n                        field: 'config',\n                        object: 'Pool',\n                        params\n                    })\n                }\n            })\n            .addProp('schema')\n            .addProp('config', {\n                type: 'object',\n                onInvalid: (...params) => {\n                    throw error('bad vector.config', {\n                        field: 'config',\n                        object: 'Pool',\n                        params\n                    })\n                }\n            })\n            .addProp('name', {\n                required: true, type: 'string',\n                onInvalid: (...params) => {\n                    throw error('bad vector.name', {\n                        field: 'config',\n                        object: 'Pool',\n                        params\n                    })\n                }\n            })\n\n        return Vector;\n    });\n}\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof Symbol !== \"undefined\") {\n\t\tvar iteratorSymbol = Symbol.iterator;\n\t\tif (iteratorSymbol && (iteratorSymbol in target)) {\n\t\t\tvar iterator = target[iteratorSymbol](), step, pact, reject;\n\t\t\tfunction _cycle(result) {\n\t\t\t\ttry {\n\t\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (pact) {\n\t\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpact = result;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t\t\t}\n\t\t\t}\n\t\t\t_cycle();\n\t\t\tif (iterator.return) {\n\t\t\t\tvar _fixup = function(value) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\t\titerator.return();\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\tif (pact && pact.then) {\n\t\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t_fixup();\n\t\t\t}\n\t\t\treturn pact;\n\t\t}\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"value is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof Symbol !== \"undefined\") {\n\t\tvar asyncIteratorSymbol = Symbol.asyncIterator;\n\t\tif (asyncIteratorSymbol && (asyncIteratorSymbol in target)) {\n\t\t\tvar pact = new _Pact();\n\t\t\tvar iterator = target[asyncIteratorSymbol]();\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t\treturn pact;\n\t\t\tfunction _resumeAfterBody(result) {\n\t\t\t\tif (check && !check()) {\n\t\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t\t}\n\t\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t\t}\n\t\t\tfunction _resumeAfterNext(step) {\n\t\t\t\tif (step.done) {\n\t\t\t\t\t_settle(pact, 1);\n\t\t\t\t} else {\n\t\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfunction _reject(error) {\n\t\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t\t}\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, value);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t\tthis[Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))] = function() {\n\t\t\treturn this;\n\t\t};\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\t_entry(_this).then(returnValue, function(error) {\n\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import {Store} from '@wonderlandlabs/looking-glass-engine';\nimport {Subject} from 'rxjs';\nimport {filter, map} from 'rxjs/operators';\nimport lGet from 'lodash.get';\nimport propper from '@wonderlandlabs/propper';\n\nexport default (bottle) => {\n\n    bottle.factory('Pool', function ({Vector, error, noop}) {\n        class Pool {\n            constructor(name, config = {}) {\n                this.name = name;\n                this.vectors = lGet(config, '_vectors', new Map());\n                this.config = lGet(config, 'config', config);\n            }\n\n            addVector(name, config, force = false) {\n                if (this.vectors.has(name) && !force) {\n                    throw error('Attempt to redefine ' + name, {\n                        config,\n                        name,\n                        pool: this\n                    })\n                }\n\n                if (config instanceof Vector) {\n                    config.pool = this;\n                    this.vectors.set(name, config);\n                } else if (typeof config === 'function') {\n                    this.vectors.set(name, new Vector(name, {pool: this, sender: config}));\n                } else {\n                    this.vectors.set(name, new Vector(name, {...config, pool: this, ...config}))\n                }\n                return this;\n            }\n\n            impulse(name, params) {\n                if (!this.vectors.has(name)) {\n                    throw error('attempt to use an unregistered vector', {\n                        pool: this,\n                        name,\n                        params\n                    })\n                }\n\n                return this.vectors.get(name).impulse(params);\n            }\n\n            get signalStream() {\n                if (!this._signalStream) {\n                    this._signalStream = new Subject();\n                }\n                return this._signalStream;\n            }\n\n            subscribe(...params) {\n                return this.signalStream.subscribe(...params);\n            }\n        };\n\n        propper(Pool)\n            .addProp('vectors', ({defaultValue: () => new Map}))\n            .addProp('name', {type: 'string', required: true})\n            .addProp('config', {\n                type: 'object', defaultValue: () => {\n                    return {};\n                },\n                onInvalid: (...params) => {\n                    throw error('bad pool.config', {\n                        field: 'config',\n                        object: 'Pool',\n                        params\n                    })\n                }\n            });\n\n        return Pool;\n    });\n}\n","import {catchError, map, switchMap} from 'rxjs/operators';\nimport {of} from 'rxjs';\n\nexport default function catchFactory(bottle) {\n  bottle.constant('noop', (a) => a);\n\n  const defaultCatcher = (err) => ({error: err, defaultCatcher: true});\n\n  /**\n   * Maps the output to a function that can throw errors.\n   * Re-maps error output to the catcher function.\n   * The resulting subscriber has pseudo-promise syntax\n   * that lets you set the mapper\n   */\n  bottle.factory('rxCatch', ({noop}) => {\n    return (observable, mapper = noop, catcher = defaultCatcher) => {\n      return observable.pipe(\n        switchMap(\n          response => of(response)\n            .pipe(\n              map(mapper),\n              catchError(error => of(catcher(error))))\n        ));\n    }\n  })\n}\n","import lGet from 'lodash.get';\nimport propper from '@wonderlandlabs/propper';\nimport {filter, map, startWith} from 'rxjs/operators';\n\nexport default (bottle) => {\n\n    bottle.factory('IMPULSE_STATE_NEW', ({Symbol}) => Symbol('IMPULSE_STATE_NEW'));\n    bottle.factory('IMPULSE_STATE_QUEUED', ({Symbol}) => Symbol('IMPULSE_STATE_QUEUED'));\n    bottle.factory('IMPULSE_STATE_SENT', ({Symbol}) => Symbol('IMPULSE_STATE_SENT'));\n    bottle.factory('IMPULSE_STATE_RESOLVED', ({Symbol}) => Symbol('IMPULSE_STATE_RESOLVED'));\n    bottle.factory('IMPULSE_STATE_UPDATED', ({Symbol}) => Symbol('IMPULSE_STATE_UPDATED'));\n    bottle.factory('IMPULSE_STATE_ERROR', ({Symbol}) => Symbol('IMPULSE_STATE_ERROR'));\n    bottle.factory('IMPULSE_STATE_COMPLETE', ({Symbol}) => Symbol('IMPULSE_STATE_COMPLETE'));\n\n    bottle.factory('Impulse', ({\n                                   UNSET, error, Signal\n                               }) => {\n\n            /**\n             * An impulse is a single call to a channel.\n             * It exists for an indefinate period before it is performed,\n             * so it can be used as a \"draft\" or prepared query that you\n             * build up and send.\n             *\n             * Once set, its response subscribes to the pools updates\n             * stream so that it can change (or present warnings) when\n             * the pool's other impulse updates are relevant to the response.\n             */\n            class Impulse {\n                constructor(config = {}) {\n                    this.vector = lGet(config, 'vector');\n                    this._params = lGet(config, 'params', config);\n                }\n\n                get params() {\n                    // @TODO: Immutable?\n                    return this._params;\n                }\n\n                get pool() {\n                    return this.vector.pool;\n                }\n\n                send() {\n                    if (this._pending) {\n                        if (this.vector.idempotent) {\n                            return this._pending;\n                        } else {\n                            return this._pending\n                                .then(() => this.send())\n                                .catch(() => this.send());\n                        }\n                    } else {\n                        const signal = new Signal(this);\n                        this._pending = this.vector.send(signal)\n                            .then(() => {\n                                this._pending = false;\n                                this.pool.signalStream.next(signal);\n                                return signal;\n                            })\n                            .catch(() => {\n                                this._pending = false;\n                                this.pool.signalStream.error(signal);\n                                return signal;\n                            })\n                    }\n\n                    return this._pending;\n                }\n\n                get signalStream() {\n                    if (!this._signalStream) {\n                        this._signalStream = this.vector.signalStream\n                            .pipe(\n                                filter(this.vector.impulseFilter(this),\n                                    map(this.vector.impulseMap(this))\n                                ));\n                    }\n                    return this._signalStream;\n                }\n\n                subscribe(...params) {\n                    if (this._completed) {\n                        throw error('cannot subscribe to completed impulse', {\n                            impulse: this, params\n                        });\n                    }\n                    const sub = this.signalStream.subscribe(...params);\n                    this._subs.push(sub);\n                    return sub;\n                }\n\n                get _subs() {\n                    if (!this.__subs) {\n                        this.__subs = [];\n                    }\n                    return this.__subs;\n                }\n\n                complete() {\n                    this._completed = true;\n                    if (this._signalStream) {\n                        this._signalStream.complete();\n                    }\n\n                    if (this.__subs) {\n                        this.__subs.forEach(s => s.unsubscribe());\n                    }\n\n                    delete this.__subs;\n                }\n            }\n\n            propper(Impulse)\n                .addProp('vector', {\n                    required: true,\n                    type: 'object',\n                    onInvalid:\n                        (err) => {\n                            throw error('bad impulse.config', {\n                                field: 'vector',\n                                object: 'Impulse',\n                                err\n                            })\n                        }\n                });\n\n            return Impulse;\n        }\n    );\n}\n","export default (bottle) => {\n\n    bottle.factory('Promiser', ({UNSET}) => {\n        return class Promiser {\n            constructor() {\n                this._resolved = false;\n                this.promise = new Promise((done, fail) => {\n                    this._done = done;\n                    this._fail = fail;\n                });\n            }\n\n            get resolved() {\n                return this._resolved;\n            }\n\n            /**\n             * _resolve (optionally) sets the final value of the change\n             * and closes the promise. It can only execute once.\n             *\n             * If value is (or is set to) a value then the change\n             * resolves that value and takes the result as the change's value\n             * then returns it.\n             *\n             * @returns {Promise}\n             * @param response\n             */\n            resolve(response) {\n                if (this.resolved) {\n                    return this.promise;\n                }\n\n                this.response = response;\n\n                this._resolved = true;\n                this._done(response);\n                return this.promise;\n            }\n\n            reject(error) {\n                if (this.resolved) {\n                    return this.promise;\n                }\n\n                this._resolved = true;\n\n                this.error = error;\n\n                this._fail(this);\n                return this.promise;\n            }\n\n            then(...args) {\n                return this.promise.then(...args);\n            }\n\n            catch(listener) {\n                return this.promise.catch(listener);\n            }\n        }\n\n\n    })\n\n\n}\n","import {Store} from '@wonderlandlabs/looking-glass-engine';\nimport lGet from 'lodash.get';\nimport axios from 'axios';\nimport urlJoin from 'url-join';\n\nexport default (bottle) => {\n\n    bottle.factory('RestPool', ({\n                                    Pool, noop, error, axios, Vector, isUnset,\n                                    REST_ACTIONS, UNSET, restChannels, DataMap\n                                }) => {\n\n        function isIterable(obj) {\n            // checks for null and undefined\n            if (obj == null) {\n                return false;\n            }\n            return typeof obj[Symbol.iterator] === 'function';\n        }\n\n        class RestPool extends Pool {\n        };\n\n        return RestPool;\n    })\n}\n","export default bottle => {\n    bottle.factory('DataMap', () => {\n        return class DataMap {\n            constructor(records, pool) {\n                this._map = new Map();\n                this.pool = pool;\n                (Array.isArray(records) ? records : [records]).forEach(data => {\n                    const id = data[pool.idField];\n                    this.set(id, data);\n                })\n            }\n\n            get size() {\n                return this._map.size;\n            }\n\n            entries() {\n                return this._map.entries();\n            }\n\n            get(k){\n                return this._map.get(k);\n            }\n\n            set(...a) {\n                return this._map.set(...a);\n            }\n\n            has(k) {\n                return this._map.has(k);\n            }\n\n            keys() {\n                return this._map.keys()\n            }\n\n            clear() {\n                return this._map.clear()\n            }\n\n            delete(k) {\n                return this._map.delete(k)\n            }\n\n            values() {\n                return this._map.values()\n            }\n\n            forEach(fn) {\n                return this._map.forEach(fn)\n            }\n\n            overlaps(otherDataMap) {\n                if (!otherDataMap instanceof DataMap) {\n                    return false;\n                }\n                if (otherDataMap.size < this.size) {\n                    return otherDataMap.overlaps(this);\n                }\n                let keys = this.keys();\n                let next = keys.next();\n                while (!next.done) {\n                    if (otherDataMap.has(next.value)) {\n                        return true;\n                    }\n                    next = keys.next();\n                }\n\n                return false;\n            }\n\n            sharedKeys(otherDataMap) {\n                if (!otherDataMap instanceof DataMap) {\n                    return false;\n                }\n                if (otherDataMap.size < this.size) {\n                    return otherDataMap.sharedKeys(this);\n                }\n                let keys = this.keys();\n                let shared = [];\n                let next = keys.next();\n\n                while (!next.done) {\n                    if (otherDataMap.has(next.value)) {\n                        shared.push(next.value);\n                    }\n                    next = keys.next();\n                }\n\n                return shared;\n            }\n\n            clone(){\n                let dm = new DataMap([], this.pool);\n                dm.updateFrom(this, true);\n                return dm;\n            }\n\n            /**\n             * copy shared values from the other map into this one.\n             * @param otherMap\n             * @param useAll {bool}\n             * @param merge {bool} if true (default), new data is combined with old data. So fields can be added but not deleted.\n             */\n            updateFrom(otherMap, useAll = false, merge = true) {\n                if (otherMap.pool !== this.pool) {\n                    console.log(error('attempt to merge data from wrong pool', {\n                        map: this,\n                        otherMap\n                    }))\n                }\n\n                otherMap.forEach((value, key) => {\n                    if ((this.has(key))) {\n                        let merged = merge ? Object.assign({}, this.get(key), value): value;\n                        this.set(key, merged);\n                    } else if (useAll) {\n                        this.set(key, value);\n                    }\n                });\n                return this;\n            }\n        }\n    });\n}\n","import lGet from 'lodash.get';\nimport axios from 'axios';\nimport {filter, map} from 'rxjs/operators';\n\nexport default (bottle) => {\n    bottle.constant('REST_ACTIONS', 'get,put,post,delete,getAll'.split(','));\n\n    bottle.factory('axios', () => axios);\n\n    bottle.factory('observeSingle', ({restDataFromImpulse, isUnset, UNSET, DataMap, noop}) => {\n        return noop;\n    });\n\n    bottle.factory('restChannels', ({UNSET, observeSingle, noop, error, restDataFromImpulse, DataMap, isUnset}) => {\n        return noop;\n    });\n\n    bottle.factory('restDataFromImpulse', ({UNSET, noop}) => {\n        return noop;\n    });\n}\n","import lGet from 'lodash.get';\nimport uuid from 'uuid/v4';\n\nexport default (bottle) => {\n\n    bottle.factory('Signal', ({UNSET, Update, error, noop, isUnset}) => {\n        /**\n         * A channel is a named operation\n         */\n        return class Signal {\n            constructor(impulse, config = {}) {\n                this.id = uuid();\n                this.response = lGet(config, 'response', null);\n                this.error = lGet(config, 'error', null);\n                this._baseSignal = lGet(config, 'baseSignal', UNSET);\n                this._impulse = impulse;\n            }\n\n            toJSON() {\n                const out = {\n                    id: this.id,\n                    pool: this.pool.name,\n                    vector: this.vector.name,\n                    query: JSON.stringify(this.query),\n                    error: lGet(this, 'error', null),\n                    response: lGet(this, 'response', null)\n                }\n\n                if (!isUnset(this._baseSignal)){\n                    out.baseSignal = this._baseSignal.toJSON();\n                }\n\n                return out;\n            }\n\n            mutate(config) {\n                return new Signal(this.impulse, {\n                    ...config,\n                    baseSignal: this\n                });\n            }\n\n            get baseSignal() {\n                return this._baseSignal;\n            }\n\n            get pool() {\n                return this.impulse.pool;\n            }\n\n            get impulse() {\n                return this._impulse;\n            }\n\n            get vector() {\n                return this.impulse.vector;\n            }\n\n            get params() {\n                return this.impulse.params;\n            }\n\n            get query() {\n                if (!this._query) {\n                    this._query = this.vector.paramsToQuery(this.impulse);\n                }\n                return this._query;\n            }\n        };\n    });\n}\n","import bottle from './bottle';\n\nconst myBottle = bottle();\nconst {\n    Pool,\n    RestPool,\n    Vector,\n    Impulse,\n    DataMap,\n    axios\n} = myBottle.container;\n\nexport {\n    Pool,\n    RestPool,\n    Vector,\n    Impulse,\n    bottle,\n    DataMap,\n    axios\n}\n\nexport default {\n    Pool,\n    RestPool,\n    Vector,\n    Impulse,\n    DataMap,\n    bottle,\n    axios\n}\n"],"names":["bottle","Bottle","factory","ref","Symbol","value","defaultValue","UNSET","item","string","name","msg","info","e","Error","Object","assign","unsetFactory","Vector","constructor","config","pool","lGet","sender","schema","_impulseFilter","_impulseMap","_paramsToQuery","noop","idempotent","impulse","params","Impulse","this","paramsToQuery","send","signal","body","recover","result","_this","query","response","Promise","resolve","then","error","reject","impulseFilter","id","isUnset","impulseMap","signalStream","_signalStream","pipe","filter","vector","subscribe","propper","addProp","type","required","onInvalid","field","object","collFactory","Pool","vectors","Map","addVector","force","has","set","get","Subject","poolFactory","constant","a","defaultCatcher","err","observable","mapper","catcher","switchMap","of","map","catchError","catchFactory","_params","_pending","catch","Signal","next","_completed","sub","_subs","push","__subs","complete","forEach","s","unsubscribe","impulseFactory","_resolved","promise","done","fail","_done","_fail","resolved","args","listener","promiserFactory","restPoolFactory","records","_map","Array","isArray","data","idField","size","entries","k","keys","clear","delete","values","fn","overlaps","otherDataMap","DataMap","sharedKeys","shared","clone","dm","updateFrom","otherMap","useAll","merge","console","log","key","merged","dataMapFactory","split","axios","restPoolUtilFactory","uuid","_baseSignal","_impulse","toJSON","out","JSON","stringify","baseSignal","mutate","_query","signalFactory","container","RestPool"],"mappings":"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"}