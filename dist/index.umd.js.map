{"version":3,"file":"index.umd.js","sources":["../node_modules/strict-uri-encode/index.js","../node_modules/object-assign/index.js","../node_modules/query-string/index.js","../node_modules/decode-uri-component/index.js","../src/bottle.js","../src/utils.js","../src/Vector.js","../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/Pool.js","../src/rxCatch.js","../src/Impulse.js","../src/Promiser.js","../src/RestPool.js","../src/DataMap.js","../src/RestPoolUtils.js","../src/Signal.js","../src/index.js"],"sourcesContent":["'use strict';\nmodule.exports = function (str) {\n\treturn encodeURIComponent(str).replace(/[!'()*]/g, function (c) {\n\t\treturn '%' + c.charCodeAt(0).toString(16).toUpperCase();\n\t});\n};\n","/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n","'use strict';\nvar strictUriEncode = require('strict-uri-encode');\nvar objectAssign = require('object-assign');\nvar decodeComponent = require('decode-uri-component');\n\nfunction encoderForArrayFormat(opts) {\n\tswitch (opts.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn function (key, value, index) {\n\t\t\t\treturn value === null ? [\n\t\t\t\t\tencode(key, opts),\n\t\t\t\t\t'[',\n\t\t\t\t\tindex,\n\t\t\t\t\t']'\n\t\t\t\t].join('') : [\n\t\t\t\t\tencode(key, opts),\n\t\t\t\t\t'[',\n\t\t\t\t\tencode(index, opts),\n\t\t\t\t\t']=',\n\t\t\t\t\tencode(value, opts)\n\t\t\t\t].join('');\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn function (key, value) {\n\t\t\t\treturn value === null ? encode(key, opts) : [\n\t\t\t\t\tencode(key, opts),\n\t\t\t\t\t'[]=',\n\t\t\t\t\tencode(value, opts)\n\t\t\t\t].join('');\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn function (key, value) {\n\t\t\t\treturn value === null ? encode(key, opts) : [\n\t\t\t\t\tencode(key, opts),\n\t\t\t\t\t'=',\n\t\t\t\t\tencode(value, opts)\n\t\t\t\t].join('');\n\t\t\t};\n\t}\n}\n\nfunction parserForArrayFormat(opts) {\n\tvar result;\n\n\tswitch (opts.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn function (key, value, accumulator) {\n\t\t\t\tresult = /\\[(\\d*)\\]$/.exec(key);\n\n\t\t\t\tkey = key.replace(/\\[\\d*\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = {};\n\t\t\t\t}\n\n\t\t\t\taccumulator[key][result[1]] = value;\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn function (key, value, accumulator) {\n\t\t\t\tresult = /(\\[\\])$/.exec(key);\n\t\t\t\tkey = key.replace(/\\[\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t} else if (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = [value];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn function (key, value, accumulator) {\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\t}\n}\n\nfunction encode(value, opts) {\n\tif (opts.encode) {\n\t\treturn opts.strict ? strictUriEncode(value) : encodeURIComponent(value);\n\t}\n\n\treturn value;\n}\n\nfunction keysSorter(input) {\n\tif (Array.isArray(input)) {\n\t\treturn input.sort();\n\t} else if (typeof input === 'object') {\n\t\treturn keysSorter(Object.keys(input)).sort(function (a, b) {\n\t\t\treturn Number(a) - Number(b);\n\t\t}).map(function (key) {\n\t\t\treturn input[key];\n\t\t});\n\t}\n\n\treturn input;\n}\n\nfunction extract(str) {\n\tvar queryStart = str.indexOf('?');\n\tif (queryStart === -1) {\n\t\treturn '';\n\t}\n\treturn str.slice(queryStart + 1);\n}\n\nfunction parse(str, opts) {\n\topts = objectAssign({arrayFormat: 'none'}, opts);\n\n\tvar formatter = parserForArrayFormat(opts);\n\n\t// Create an object with no prototype\n\t// https://github.com/sindresorhus/query-string/issues/47\n\tvar ret = Object.create(null);\n\n\tif (typeof str !== 'string') {\n\t\treturn ret;\n\t}\n\n\tstr = str.trim().replace(/^[?#&]/, '');\n\n\tif (!str) {\n\t\treturn ret;\n\t}\n\n\tstr.split('&').forEach(function (param) {\n\t\tvar parts = param.replace(/\\+/g, ' ').split('=');\n\t\t// Firefox (pre 40) decodes `%3D` to `=`\n\t\t// https://github.com/sindresorhus/query-string/pull/37\n\t\tvar key = parts.shift();\n\t\tvar val = parts.length > 0 ? parts.join('=') : undefined;\n\n\t\t// missing `=` should be `null`:\n\t\t// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n\t\tval = val === undefined ? null : decodeComponent(val);\n\n\t\tformatter(decodeComponent(key), val, ret);\n\t});\n\n\treturn Object.keys(ret).sort().reduce(function (result, key) {\n\t\tvar val = ret[key];\n\t\tif (Boolean(val) && typeof val === 'object' && !Array.isArray(val)) {\n\t\t\t// Sort object keys, not values\n\t\t\tresult[key] = keysSorter(val);\n\t\t} else {\n\t\t\tresult[key] = val;\n\t\t}\n\n\t\treturn result;\n\t}, Object.create(null));\n}\n\nexports.extract = extract;\nexports.parse = parse;\n\nexports.stringify = function (obj, opts) {\n\tvar defaults = {\n\t\tencode: true,\n\t\tstrict: true,\n\t\tarrayFormat: 'none'\n\t};\n\n\topts = objectAssign(defaults, opts);\n\n\tif (opts.sort === false) {\n\t\topts.sort = function () {};\n\t}\n\n\tvar formatter = encoderForArrayFormat(opts);\n\n\treturn obj ? Object.keys(obj).sort(opts.sort).map(function (key) {\n\t\tvar val = obj[key];\n\n\t\tif (val === undefined) {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (val === null) {\n\t\t\treturn encode(key, opts);\n\t\t}\n\n\t\tif (Array.isArray(val)) {\n\t\t\tvar result = [];\n\n\t\t\tval.slice().forEach(function (val2) {\n\t\t\t\tif (val2 === undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tresult.push(formatter(key, val2, result.length));\n\t\t\t});\n\n\t\t\treturn result.join('&');\n\t\t}\n\n\t\treturn encode(key, opts) + '=' + encode(val, opts);\n\t}).filter(function (x) {\n\t\treturn x.length > 0;\n\t}).join('&') : '';\n};\n\nexports.parseUrl = function (str, opts) {\n\treturn {\n\t\turl: str.split('?')[0] || '',\n\t\tquery: parse(extract(str), opts)\n\t};\n};\n","'use strict';\nvar token = '%[a-f0-9]{2}';\nvar singleMatcher = new RegExp(token, 'gi');\nvar multiMatcher = new RegExp('(' + token + ')+', 'gi');\n\nfunction decodeComponents(components, split) {\n\ttry {\n\t\t// Try to decode the entire string first\n\t\treturn decodeURIComponent(components.join(''));\n\t} catch (err) {\n\t\t// Do nothing\n\t}\n\n\tif (components.length === 1) {\n\t\treturn components;\n\t}\n\n\tsplit = split || 1;\n\n\t// Split the array in 2 parts\n\tvar left = components.slice(0, split);\n\tvar right = components.slice(split);\n\n\treturn Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n}\n\nfunction decode(input) {\n\ttry {\n\t\treturn decodeURIComponent(input);\n\t} catch (err) {\n\t\tvar tokens = input.match(singleMatcher);\n\n\t\tfor (var i = 1; i < tokens.length; i++) {\n\t\t\tinput = decodeComponents(tokens, i).join('');\n\n\t\t\ttokens = input.match(singleMatcher);\n\t\t}\n\n\t\treturn input;\n\t}\n}\n\nfunction customDecodeURIComponent(input) {\n\t// Keep track of all the replacements and prefill the map with the `BOM`\n\tvar replaceMap = {\n\t\t'%FE%FF': '\\uFFFD\\uFFFD',\n\t\t'%FF%FE': '\\uFFFD\\uFFFD'\n\t};\n\n\tvar match = multiMatcher.exec(input);\n\twhile (match) {\n\t\ttry {\n\t\t\t// Decode as big chunks as possible\n\t\t\treplaceMap[match[0]] = decodeURIComponent(match[0]);\n\t\t} catch (err) {\n\t\t\tvar result = decode(match[0]);\n\n\t\t\tif (result !== match[0]) {\n\t\t\t\treplaceMap[match[0]] = result;\n\t\t\t}\n\t\t}\n\n\t\tmatch = multiMatcher.exec(input);\n\t}\n\n\t// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n\treplaceMap['%C2'] = '\\uFFFD';\n\n\tvar entries = Object.keys(replaceMap);\n\n\tfor (var i = 0; i < entries.length; i++) {\n\t\t// Replace all decoded components\n\t\tvar key = entries[i];\n\t\tinput = input.replace(new RegExp(key, 'g'), replaceMap[key]);\n\t}\n\n\treturn input;\n}\n\nmodule.exports = function (encodedURI) {\n\tif (typeof encodedURI !== 'string') {\n\t\tthrow new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\n\t}\n\n\ttry {\n\t\tencodedURI = encodedURI.replace(/\\+/g, ' ');\n\n\t\t// Try the built in decoder first\n\t\treturn decodeURIComponent(encodedURI);\n\t} catch (err) {\n\t\t// Fallback to a more advanced decoder\n\t\treturn customDecodeURIComponent(encodedURI);\n\t}\n};\n","import Bottle from 'bottlejs';\n\nimport collFactory from './Vector';\nimport poolFactory from './Pool';\nimport impulseFactory from './Impulse';\nimport catchFactory from './rxCatch';\nimport promiserFactory from './Promiser';\nimport unsetFactory from './utils';\nimport restPoolFactory from './RestPool';\nimport restPoolUtilFactory from './RestPoolUtils';\nimport dataMapFactory from './DataMap';\nimport signalFactory from './Signal';\n\nexport default () => {\n    let bottle = new Bottle();\n    unsetFactory(bottle);\n    collFactory(bottle);\n    poolFactory(bottle);\n    catchFactory(bottle);\n    impulseFactory(bottle);\n    promiserFactory(bottle);\n    restPoolFactory(bottle);\n    dataMapFactory(bottle);\n    restPoolUtilFactory(bottle);\n    signalFactory(bottle);\n    return bottle;\n}\n","export default function unsetFactory(bottle) {\n    bottle.factory('UNSET', ({Symbol}) => Symbol('UNSET'));\n    bottle.factory('ifUnset', ({UNSET}) => {\n        return (value, defaultValue) => {\n            if ((value === UNSET) || (typeof value === \"undefined\")) {\n                return defaultValue;\n            } else {\n                return value;\n            }\n        }\n    });\n\n    bottle.factory('isUnset', ({UNSET}) => {\n        return (item) => item === UNSET;\n    });\n\n    bottle.factory('Symbol', ({noop}) => {\n        return (string) => ({name: string});\n    });\n\n    bottle.factory('error', () => (msg, info) => {\n        let e = new Error(msg);\n        if (info) {\n            return Object.assign(e, {info})\n        }\n        return e;\n    });\n}\n","import propper from '@wonderlandlabs/propper';\nimport lGet from 'lodash.get';\nimport {filter, map, startWith} from 'rxjs/operators';\nimport uuid from 'uuid/v4';\n\nexport default (bottle) => {\n\n    bottle.factory('Vector', ({UNSET, Update, Impulse, error, noop, isUnset}) => {\n        /**\n         * A channel is a named operation\n         */\n        class Vector {\n            constructor(name, config = {}) {\n                this.pool = lGet(config, 'pool');\n                this.sender = lGet(config, 'sender');\n                this.config = lGet(config, 'config', config);\n                this.schema = lGet(config, 'schema');\n                this._impulseFilter = lGet(config, 'impulseFilter', UNSET);\n                this._impulseMap = lGet(config, 'impulseMap', UNSET);\n                this._paramsToQuery = lGet(config, 'paramsToQuery', noop);\n                this.idempotent = lGet(config, 'idempotent', false)\n                this.name = name;\n            }\n\n            impulse(params = {}) {\n                return new Impulse({\n                    vector: this,\n                    params\n                })\n            }\n\n            paramsToQuery(impulse) {\n                return this._paramsToQuery(impulse.params, impulse, this);\n            }\n\n            async send(signal) {\n                try {\n                    signal.response = await this.sender(signal.query, signal);\n                    return Promise.resolve(signal);\n                } catch (error) {\n                    signal.error = error;\n                    return Promise.reject(signal);\n                }\n            }\n\n            impulseFilter(impulse) {\n                const id = impulse.id;\n                return isUnset(this._impulseFilter) ? (signal => signal.impulse.id === id)\n                    : this._impulseFilter(impulse, this);\n            }\n\n            impulseMap(impulse) {\n                return isUnset(this._impulseMap) ? noop\n                    : this._impulseMap(impulse, this);\n            }\n\n            get signalStream() {\n                if (!this._signalStream) {\n                    this._signalStream = this.pool.signalStream\n                        .pipe(filter(signal => signal.vector.name === this.name));\n                }\n                return this._signalStream;\n            }\n\n            subscribe(...params) {\n                return this.signalStream.subscribe(...params);\n            }\n        };\n\n        propper(Vector)\n            .addProp('idempotent', {\n                type: 'boolean',\n                defaultValue: false\n            })\n            .addProp('pool', {\n                required: true, type: 'object',\n                onInvalid: (...params) => {\n                    throw error('bad vector.pool', {\n                        field: 'config',\n                        object: 'Pool',\n                        params\n                    })\n                }\n            })\n            .addProp('sender', {\n                required: true, type: 'function',\n                onInvalid: (...params) => {\n                    throw error('bad vector.sender', {\n                        field: 'config',\n                        object: 'Pool',\n                        params\n                    })\n                }\n            })\n            .addProp('schema')\n            .addProp('config', {\n                type: 'object',\n                onInvalid: (...params) => {\n                    throw error('bad vector.config', {\n                        field: 'config',\n                        object: 'Pool',\n                        params\n                    })\n                }\n            })\n            .addProp('name', {\n                required: true, type: 'string',\n                onInvalid: (...params) => {\n                    throw error('bad vector.name', {\n                        field: 'config',\n                        object: 'Pool',\n                        params\n                    })\n                }\n            })\n\n        return Vector;\n    });\n}\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof Symbol !== \"undefined\") {\n\t\tvar iteratorSymbol = Symbol.iterator;\n\t\tif (iteratorSymbol && (iteratorSymbol in target)) {\n\t\t\tvar iterator = target[iteratorSymbol](), step, pact, reject;\n\t\t\tfunction _cycle(result) {\n\t\t\t\ttry {\n\t\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (pact) {\n\t\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpact = result;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t\t\t}\n\t\t\t}\n\t\t\t_cycle();\n\t\t\tif (iterator.return) {\n\t\t\t\tvar _fixup = function(value) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\t\titerator.return();\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\tif (pact && pact.then) {\n\t\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t_fixup();\n\t\t\t}\n\t\t\treturn pact;\n\t\t}\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"value is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof Symbol !== \"undefined\") {\n\t\tvar asyncIteratorSymbol = Symbol.asyncIterator;\n\t\tif (asyncIteratorSymbol && (asyncIteratorSymbol in target)) {\n\t\t\tvar pact = new _Pact();\n\t\t\tvar iterator = target[asyncIteratorSymbol]();\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t\treturn pact;\n\t\t\tfunction _resumeAfterBody(result) {\n\t\t\t\tif (check && !check()) {\n\t\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t\t}\n\t\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t\t}\n\t\t\tfunction _resumeAfterNext(step) {\n\t\t\t\tif (step.done) {\n\t\t\t\t\t_settle(pact, 1);\n\t\t\t\t} else {\n\t\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfunction _reject(error) {\n\t\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t\t}\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, value);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t\tthis[Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))] = function() {\n\t\t\treturn this;\n\t\t};\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\t_entry(_this).then(returnValue, function(error) {\n\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import {Store} from '@wonderlandlabs/looking-glass-engine';\nimport {Subject} from 'rxjs';\nimport {filter, map} from 'rxjs/operators';\nimport lGet from 'lodash.get';\nimport propper from '@wonderlandlabs/propper';\n\nexport default (bottle) => {\n\n    bottle.factory('Pool', function ({Vector, error, noop}) {\n        class Pool {\n            constructor(name, config = {}) {\n                this.name = name;\n                this.vectors = lGet(config, '_vectors', new Map());\n                this.config = lGet(config, 'config', config);\n            }\n\n            addVector(name, config, force = false) {\n                if (this.vectors.has(name) && !force) {\n                    throw error('Attempt to redefine ' + name, {\n                        config,\n                        name,\n                        pool: this\n                    })\n                }\n\n                if (config instanceof Vector) {\n                    config.pool = this;\n                    this.vectors.set(name, config);\n                } else if (typeof config === 'function') {\n                    this.vectors.set(name, new Vector(name, {pool: this, sender: config}));\n                } else {\n                    this.vectors.set(name, new Vector(name, {...config, pool: this, ...config}))\n                }\n                return this;\n            }\n\n            impulse(name, ...params) {\n                if (!this.vectors.has(name)) {\n                    throw error('attempt to use an unregistered vector', {\n                        pool: this,\n                        name,\n                        params\n                    })\n                }\n\n                return this.vectors.get(name).impulse(params);\n            }\n\n            get signalStream() {\n                if (!this._signalStream) {\n                    this._signalStream = new Subject();\n                }\n                return this._signalStream;\n            }\n\n            subscribe(...params) {\n                return this.signalStream.subscribe(...params);\n            }\n        };\n\n        propper(Pool)\n            .addProp('vectors', ({defaultValue: () => new Map}))\n            .addProp('name', {type: 'string', required: true})\n            .addProp('config', {\n                type: 'object', defaultValue: () => {\n                    return {};\n                },\n                onInvalid: (...params) => {\n                    throw error('bad pool.config', {\n                        field: 'config',\n                        object: 'Pool',\n                        params\n                    })\n                }\n            });\n\n        return Pool;\n    });\n}\n","import {catchError, map, switchMap} from 'rxjs/operators';\nimport {of} from 'rxjs';\n\nexport default function catchFactory(bottle) {\n  bottle.constant('noop', (a) => a);\n\n  const defaultCatcher = (err) => ({error: err, defaultCatcher: true});\n\n  /**\n   * Maps the output to a function that can throw errors.\n   * Re-maps error output to the catcher function.\n   * The resulting subscriber has pseudo-promise syntax\n   * that lets you set the mapper\n   */\n  bottle.factory('rxCatch', ({noop}) => {\n    return (observable, mapper = noop, catcher = defaultCatcher) => {\n      return observable.pipe(\n        switchMap(\n          response => of(response)\n            .pipe(\n              map(mapper),\n              catchError(error => of(catcher(error))))\n        ));\n    }\n  })\n}\n","import lGet from 'lodash.get';\nimport uuid from 'uuid/v4';\nimport propper from '@wonderlandlabs/propper';\nimport {filter, map, startWith} from 'rxjs/operators';\n\nexport default (bottle) => {\n\n    bottle.factory('IMPULSE_STATE_NEW', ({Symbol}) => Symbol('IMPULSE_STATE_NEW'));\n    bottle.factory('IMPULSE_STATE_QUEUED', ({Symbol}) => Symbol('IMPULSE_STATE_QUEUED'));\n    bottle.factory('IMPULSE_STATE_SENT', ({Symbol}) => Symbol('IMPULSE_STATE_SENT'));\n    bottle.factory('IMPULSE_STATE_RESOLVED', ({Symbol}) => Symbol('IMPULSE_STATE_RESOLVED'));\n    bottle.factory('IMPULSE_STATE_UPDATED', ({Symbol}) => Symbol('IMPULSE_STATE_UPDATED'));\n    bottle.factory('IMPULSE_STATE_ERROR', ({Symbol}) => Symbol('IMPULSE_STATE_ERROR'));\n    bottle.factory('IMPULSE_STATE_COMPLETE', ({Symbol}) => Symbol('IMPULSE_STATE_COMPLETE'));\n\n    bottle.factory('Impulse', ({\n                                   UNSET, error, Signal\n                               }) => {\n\n            /**\n             * An impulse is a single call to a channel.\n             * It exists for an indefinate period before it is performed,\n             * so it can be used as a \"draft\" or prepared query that you\n             * build up and send.\n             *\n             * Once set, its response subscribes to the pools updates\n             * stream so that it can change (or present warnings) when\n             * the pool's other impulse updates are relevant to the response.\n             */\n            class Impulse {\n                constructor(config = {}) {\n                    this.id = uuid();\n                    this.vector = lGet(config, 'vector');\n                    this.params = lGet(config, 'params', config);\n                }\n\n                get pool() {\n                    return this.vector.pool;\n                }\n\n                send() {\n                    if (this._pending) {\n                        if (this.vector.idempotent) {\n                            return this._pending;\n                        } else {\n                            return this._pending\n                                .then(() => this.send())\n                                .catch(() => this.send());\n                        }\n                    } else {\n                        const signal = new Signal(this);\n                        this._pending = this.vector.send(signal)\n                            .then(() => {\n                                this._pending = false;\n                                this.pool.signalStream.next(signal);\n                                return signal;\n                            })\n                            .catch(() => {\n                                this._pending = false;\n                                this.pool.signalStream.error(signal);\n                                return signal;\n                            })\n                    }\n\n                    return this._pending;\n                }\n\n                get signalStream() {\n                    if (!this._signalStream) {\n                        this._signalStream = this.vector.signalStream\n                            .pipe(\n                                filter(this.vector.impulseFilter(this),\n                                    map(this.vector.impulseMap(this))\n                                ));\n                    }\n                    return this._signalStream;\n                }\n\n                subscribe(...params) {\n                    if (this._completed) {\n                        throw error('cannot subscribe to completed impulse', {\n                            impulse: this, params\n                        });\n                    }\n                    const sub = this.signalStream.subscribe(...params);\n                    this._subs.push(sub);\n                    return sub;\n                }\n\n                get _subs() {\n                    if (!this.__subs) {\n                        this.__subs = [];\n                    }\n                    return this.__subs;\n                }\n\n                complete() {\n                    this._completed = true;\n                    if (this._signalStream) {\n                        this._signalStream.complete();\n                    }\n\n                    if (this.__subs) {\n                        this.__subs.forEach(s => s.unsubscribe());\n                    }\n\n                    delete this.__subs;\n                }\n            }\n\n            propper(Impulse)\n                .addProp('params', {\n                    type: 'array',\n                    required: true\n                })\n                .addProp('vector', {\n                    required: true,\n                    type: 'object',\n                    onInvalid:\n                        (err) => {\n                            throw error('bad impulse.config', {\n                                field: 'vector',\n                                object: 'Impulse',\n                                err\n                            })\n                        }\n                });\n\n            return Impulse;\n        }\n    );\n}\n","export default (bottle) => {\n\n    bottle.factory('Promiser', ({UNSET}) => {\n        return class Promiser {\n            constructor() {\n                this._resolved = false;\n                this.promise = new Promise((done, fail) => {\n                    this._done = done;\n                    this._fail = fail;\n                });\n            }\n\n            get resolved() {\n                return this._resolved;\n            }\n\n            /**\n             * _resolve (optionally) sets the final value of the change\n             * and closes the promise. It can only execute once.\n             *\n             * If value is (or is set to) a value then the change\n             * resolves that value and takes the result as the change's value\n             * then returns it.\n             *\n             * @returns {Promise}\n             * @param response\n             */\n            resolve(response) {\n                if (this.resolved) {\n                    return this.promise;\n                }\n\n                this.response = response;\n\n                this._resolved = true;\n                this._done(response);\n                return this.promise;\n            }\n\n            reject(error) {\n                if (this.resolved) {\n                    return this.promise;\n                }\n\n                this._resolved = true;\n\n                this.error = error;\n\n                this._fail(this);\n                return this.promise;\n            }\n\n            then(...args) {\n                return this.promise.then(...args);\n            }\n\n            catch(listener) {\n                return this.promise.catch(listener);\n            }\n        }\n\n\n    })\n\n\n}\n","import {Store} from '@wonderlandlabs/looking-glass-engine';\nimport lGet from 'lodash.get';\nimport axios from 'axios';\nimport urlJoin from 'url-join';\nimport querystring from 'query-string';\nimport propper from \"@wonderlandlabs/propper\";\n\nexport default (bottle) => {\n\n    bottle.factory('RestPool', ({\n                                    Pool, error, isUnset, noop, axios,\n                                    REST_ACTIONS, UNSET, restVectors, impulseParamsToQuery\n                                }) => {\n\n        class RestPool extends Pool {\n            constructor(name, config) {\n                super(name, config);\n                this.baseURL = lGet(config, 'baseURL', '/');\n                this.prepQuery = lGet(config, 'prepQuery', null);\n                this.identityField = lGet(config, 'identityField', 'id');\n                this.responseToData = lGet(config, 'responseToData', noop);\n                this.dataToClass = lGet(config, 'dataToClass', noop);\n                this.connection = lGet(config, 'connection', axios);\n                this.impulseParamsToQuery = lGet(config, 'impulseParamsToQuery', impulseParamsToQuery)\n\n                let restActions = lGet(config, 'restActions', UNSET);\n                if (isUnset(restActions)) {\n                    REST_ACTIONS.forEach((action) => {\n                        this.addVector(action, restVectors[action]);\n                    });\n                } else {\n                    restActions.forEach((action) => {\n                        if (typeof action === 'string') {\n                            this.addVector(action, restVectors[action]);\n                        } else if (Array.isArray(action)) {\n                            const [name, config] = action;\n                            this.addVector(name, config);\n                        } else {\n                            throw error('strange action for pool ' + name, {action});\n                        }\n                    });\n                }\n            }\n\n            url(id, query) {\n                let str = urlJoin(this.baseURL, id);\n                if (query) {\n                    str += '?' + querystring.stringify(query);\n                }\n                return str;\n            }\n        };\n\n        propper(RestPool)\n            .addProp('identityField', {\n                type: 'string',\n                required: true,\n                defaultValue: 'id'\n            })\n            .addProp('responseToData', {\n                type: 'function',\n                defaultValue() {\n                    return noop\n                },\n                required: true\n            })\n            .addProp('prepQuery', {\n                type: 'function',\n                defaultValue() {\n                    return noop\n                },\n                required: false\n            })\n            .addProp('dataToClass', {\n                type: 'function',\n                defaultValue() {\n                    return noop\n                },\n            })\n            .addProp('baseURL', {\n                type: 'string',\n                defaultValue: '/',\n                required: true,\n                test: [\n                    (value) => {\n                        if (value === '/') {\n                            return true;\n                        }\n                        return /$http(s)?:\\/\\/.+/.test(value);\n                    },\n                    false,\n                    'badly formed URL'\n                ]\n            });\n\n        return RestPool;\n    })\n}\n","export default bottle => {\n    bottle.factory('DataMap', () => {\n        return class DataMap {\n            constructor(records, pool) {\n                this._map = new Map();\n                this.pool = pool;\n                (Array.isArray(records) ? records : [records]).forEach(data => {\n                    const id = data[pool.idField];\n                    this.set(id, data);\n                })\n            }\n\n            get size() {\n                return this._map.size;\n            }\n\n            entries() {\n                return this._map.entries();\n            }\n\n            get(k){\n                return this._map.get(k);\n            }\n\n            set(...a) {\n                return this._map.set(...a);\n            }\n\n            has(k) {\n                return this._map.has(k);\n            }\n\n            keys() {\n                return this._map.keys()\n            }\n\n            clear() {\n                return this._map.clear()\n            }\n\n            delete(k) {\n                return this._map.delete(k)\n            }\n\n            values() {\n                return this._map.values()\n            }\n\n            forEach(fn) {\n                return this._map.forEach(fn)\n            }\n\n            overlaps(otherDataMap) {\n                if (!otherDataMap instanceof DataMap) {\n                    return false;\n                }\n                if (otherDataMap.size < this.size) {\n                    return otherDataMap.overlaps(this);\n                }\n                let keys = this.keys();\n                let next = keys.next();\n                while (!next.done) {\n                    if (otherDataMap.has(next.value)) {\n                        return true;\n                    }\n                    next = keys.next();\n                }\n\n                return false;\n            }\n\n            sharedKeys(otherDataMap) {\n                if (!otherDataMap instanceof DataMap) {\n                    return false;\n                }\n                if (otherDataMap.size < this.size) {\n                    return otherDataMap.sharedKeys(this);\n                }\n                let keys = this.keys();\n                let shared = [];\n                let next = keys.next();\n\n                while (!next.done) {\n                    if (otherDataMap.has(next.value)) {\n                        shared.push(next.value);\n                    }\n                    next = keys.next();\n                }\n\n                return shared;\n            }\n\n            clone(){\n                let dm = new DataMap([], this.pool);\n                dm.updateFrom(this, true);\n                return dm;\n            }\n\n            /**\n             * copy shared values from the other map into this one.\n             * @param otherMap\n             * @param useAll {bool}\n             * @param merge {bool} if true (default), new data is combined with old data. So fields can be added but not deleted.\n             */\n            updateFrom(otherMap, useAll = false, merge = true) {\n                if (otherMap.pool !== this.pool) {\n                    console.log(error('attempt to merge data from wrong pool', {\n                        map: this,\n                        otherMap\n                    }))\n                }\n\n                otherMap.forEach((value, key) => {\n                    if ((this.has(key))) {\n                        let merged = merge ? Object.assign({}, this.get(key), value): value;\n                        this.set(key, merged);\n                    } else if (useAll) {\n                        this.set(key, value);\n                    }\n                });\n                return this;\n            }\n        }\n    });\n}\n","import lGet from 'lodash.get';\nimport axios from 'axios';\nimport {filter, map} from 'rxjs/operators';\n\nexport default (bottle) => {\n    bottle.constant('REST_ACTIONS', 'get,put,post,delete,getAll'.split(','));\n\n    bottle.factory('axios', () => axios);\n\n    bottle.factory('observeSingle', ({restDataFromImpulse, isUnset, UNSET, DataMap, noop}) => {\n        return noop;\n    });\n\n    bottle.factory('restChannels', ({UNSET, observeSingle, noop, error, restDataFromImpulse, DataMap, isUnset}) => {\n        return noop;\n    });\n\n    bottle.factory('restDataFromImpulse', ({UNSET, noop}) => {\n        return noop;\n    });\n}\n","import lGet from 'lodash.get';\nimport uuid from 'uuid/v4';\n\nexport default (bottle) => {\n\n    bottle.factory('Signal', ({UNSET, Update, error, noop, isUnset}) => {\n        /**\n         * A channel is a named operation\n         */\n        return class Signal {\n            constructor(impulse, config = {}) {\n                this.id = uuid();\n                this.response = lGet(config, 'response', null);\n                this.error = lGet(config, 'error', null);\n                this._baseSignal = lGet(config, 'baseSignal', UNSET);\n                this._impulse = impulse;\n            }\n\n            toJSON() {\n                const out = {\n                    id: this.id,\n                    pool: this.pool.name,\n                    vector: this.vector.name,\n                    query: JSON.stringify(this.query),\n                    error: lGet(this, 'error', null),\n                    response: lGet(this, 'response', null),\n                    impulseId: this.impulse.id\n                }\n\n                if (!isUnset(this._baseSignal)){\n                    out.baseSignal = this._baseSignal.toJSON();\n                }\n\n                return out;\n            }\n\n            mutate(config) {\n                return new Signal(this.impulse, {\n                    ...config,\n                    baseSignal: this\n                });\n            }\n\n            get baseSignal() {\n                return this._baseSignal;\n            }\n\n            get pool() {\n                return this.impulse.pool;\n            }\n\n            get impulse() {\n                return this._impulse;\n            }\n\n            get vector() {\n                return this.impulse.vector;\n            }\n\n            get params() {\n                return this.impulse.params;\n            }\n\n            get query() {\n                if (!this._query) {\n                    this._query = this.vector.paramsToQuery(this.impulse);\n                }\n                return this._query;\n            }\n        };\n    });\n}\n","import bottle from './bottle';\n\nconst myBottle = bottle();\nconst {\n    Pool,\n    RestPool,\n    Vector,\n    Impulse,\n    DataMap,\n    axios\n} = myBottle.container;\n\nexport {\n    Pool,\n    RestPool,\n    Vector,\n    Impulse,\n    bottle,\n    DataMap,\n    axios\n}\n\nexport default {\n    Pool,\n    RestPool,\n    Vector,\n    Impulse,\n    DataMap,\n    bottle,\n    axios\n}\n"],"names":["str","encodeURIComponent","replace","c","charCodeAt","toString","toUpperCase","getOwnPropertySymbols","Object","hasOwnProperty","prototype","propIsEnumerable","propertyIsEnumerable","assign","test1","String","getOwnPropertyNames","test2","i","fromCharCode","map","n","join","test3","split","forEach","letter","keys","err","shouldUseNative","target","source","from","symbols","to","val","TypeError","toObject","s","arguments","length","key","call","encode","value","opts","strict","strictUriEncode","RegExp","bottle","Bottle","factory","ref","Symbol","defaultValue","UNSET","item","string","name","msg","info","e","Error","unsetFactory","Vector","constructor","config","pool","lGet","sender","schema","_impulseFilter","_impulseMap","_paramsToQuery","noop","idempotent","impulse","params","Impulse","this","paramsToQuery","send","signal","body","recover","result","_this","query","response","Promise","resolve","then","error","reject","impulseFilter","id","isUnset","impulseMap","signalStream","_signalStream","pipe","filter","vector","subscribe","propper","addProp","type","required","onInvalid","field","object","collFactory","Pool","vectors","Map","addVector","force","has","set","get","Subject","poolFactory","constant","a","defaultCatcher","observable","mapper","catcher","switchMap","of","catchError","catchFactory","uuid","_pending","catch","Signal","next","_completed","sub","_subs","push","__subs","complete","unsubscribe","impulseFactory","_resolved","promise","done","fail","_done","_fail","resolved","args","listener","promiserFactory","RestPool","baseURL","prepQuery","identityField","responseToData","dataToClass","connection","axios","impulseParamsToQuery","restActions","REST_ACTIONS","action","restVectors","Array","isArray","url","urlJoin","obj","objectAssign","arrayFormat","sort","formatter","index","encoderForArrayFormat","undefined","slice","val2","x","querystring","test","restPoolFactory","records","_map","data","idField","size","entries","k","clear","delete","values","fn","overlaps","otherDataMap","DataMap","sharedKeys","shared","clone","dm","updateFrom","otherMap","useAll","merge","console","log","merged","dataMapFactory","restPoolUtilFactory","_baseSignal","_impulse","toJSON","out","JSON","stringify","impulseId","baseSignal","mutate","_query","signalFactory","container"],"mappings":"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"}